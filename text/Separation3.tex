%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% datoteka diploma-vzorec.tex
%
% vzorčna datoteka za pisanje diplomskega dela v formatu LaTeX
% na UL Fakulteti za računalništvo in informatiko
%
% vkup spravil Gašper Fijavž, december 2010
% množica popravkov v januarju, februarju marcu 2011
% verzija 29. marec 2011

\documentclass[a4paper, 12pt]{book}

\usepackage[utf8x]{inputenc}   % omogoča uporabo slovenskih črk kodiranih v formatu UTF-8 
\usepackage[slovene,english]{babel}    % naloži, med drugim, slovenske delilne vzorce
\usepackage[pdftex]{graphicx}  % omogoča vlaganje slik različnih formatov 
\usepackage{fancyhdr}          % poskrbi, na primer, za glave strani

\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{latexsym}
\usepackage{amssymb}           % dodatni simboli
\usepackage{amsmath}           % eqref, npr.
\usepackage{amsthm}
\usepackage{ifthen}
\usepackage{clrscode3e}
\usepackage{fancybox}
\usepackage{filecontents}
\usepackage{varwidth}
\usepackage{afterpage}
\usepackage{placeins}

\usepackage{float}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{listings}
\usepackage{framed}

\usepackage{caption}
\captionsetup[lstlisting]{font={small,tt}}
\usepackage{color}
\usepackage{textcomp}


\usepackage[mathlines]{lineno}
\usepackage{titlesec}



%\newtheorem{theorem}{Theorem}
%\newtheorem{corollary}[theorem]{Corollary}
%\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{problem}[theorem]{Problem}
%\newtheorem{proposition}[theorem]{Proposition}
%\newtheorem{conjecture}[theorem]{Conjecture}

\renewcommand{\baselinestretch}{1.3} % ustrezen razmik med vrsticami

%oznake strani
\renewcommand{\chaptermark}[1]%
{\markboth{\MakeUppercase{\thechapter.\ #1}}{}} \renewcommand{\sectionmark}[1]%
{\markright{\MakeUppercase{\thesection.\ #1}}} \renewcommand{\headrulewidth}{0.5pt} \renewcommand{\footrulewidth}{0pt} 
\fancyhf{}
\fancyhead[LE,RO]{\sl \thepage} \fancyhead[LO]{\sl \rightmark} \fancyhead[RE]{\sl \leftmark}

\newcommand{\BibTeX}{{\sc Bib}\TeX}

\newcommand{\autfont}{\Large}
\newcommand{\titfont}{\LARGE\bf}
\newcommand{\D}{\ensuremath{\mathcal{D}}} 
\newcommand{\LL}{\ensuremath{\mathbb L}}
\newcommand{\RR}{\ensuremath{\mathbb R}}  % real numbers 
\newcommand{\NN}{\ensuremath{\mathbb N}}  % natural numbers 
\newcommand{\GG}{\ensuremath{G_{\le 1}}}
\newcommand{\T}{\ensuremath{\mathcal{T}}} 
\newcommand{\OO}{\ensuremath{\mathcal{O}}} % big O notation
\newcommand{\U}{\texttt{\_}}
\newcommand{\clearemptydoublepage}{\newpage{\pagestyle{empty}\cleardoublepage}}
\setcounter{tocdepth}{1}	      % globina kazala
\setcounter{secnumdepth}{4}
\def\length{\mathrm{len}}

% konstrukti
\newtheorem{izrek}{Izrek}[chapter]
%\newtheorem{trditev}{Trditev}[izrek]
\newtheorem{lema}[izrek]{Lema}
\newenvironment{dokaz}{\emph{Dokaz.}\ }{\hspace{\fill}{$\Box$}}

\def\best{\mathit{best}}
\def\dist{\mathit{dist}}
\newcommand{\cycle}{\mathit{cycle}}
\newcommand{\walk}{\mathit{walk}}
\newcommand\CR{\mbox{\tt cr}_2}		  % crossing number

\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\definecolor{darkgreen}{rgb}{0.0, 0.2, 0.13}
%\lstdefinestyle{customc}{
%  belowcaptionskip=1\baselineskip,
%  breaklines=true,
%  frame=L,
%  xleftmargin=\parindent,
%  language=C,
%  showstringspaces=false,
%  basicstyle=\footnotesize\ttfamily,
%  keywordstyle=\bfseries\color{red},
%  commentstyle=\itshape\color{green},
%  identifierstyle=\color{blue},
%  stringstyle=\color{orange},
%}

%\lstset{escapechar=@,style=customc}
%\lstset{
%%backgroundcolor=\color{lbcolor},
%    tabsize=4,    
%%   rulecolor=,
%    language=C++,
%        basicstyle=\scriptsize,
%        upquote=true,
%        aboveskip={1.5\baselineskip},
%        columns=fixed,
%        showstringspaces=false,
%        extendedchars=false,
%        breaklines=true,
%        prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
%        frame=single,
%        numbers=left,
%        showtabs=false,
%        showspaces=false,
%        showstringspaces=false
%%        \lstdefinestyle{C++}{language=C++,style=numbers}’.
%}
\lstset{
    %backgroundcolor=\color{lbcolor},
    tabsize=4,
  language=C++,
  captionpos=b,
  tabsize=3,
  frame=lines,
  numbers=left,
  numberstyle=\tiny,
  numbersep=5pt,
  breaklines=true,
  showstringspaces=false
}

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\begin{document}
\selectlanguage{slovene}
\frontmatter
\setcounter{tocdepth}{2}
\setcounter{page}{1} %
\renewcommand{\thepage}{}       % preprecimo težave s številkami strani v kazalu 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%naslovnica
 \thispagestyle{empty}%
   \begin{center}
    {\large\sc Univerza v Ljubljani\\%
      Fakulteta za matematiko in fiziko\\
      Fakulteta za računalništvo in informatiko}%
    \vskip 10em%
    {\autfont Lazar Milinković\par}%
    {\titfont Implementacija algoritmov za probleme najkrajših poti v geometrijskih grafih \par}%
    {\vskip 2em \textsc{MAGISTRSKO DELO\\[2mm] 
    UNIVERZITETNI ŠTUDIJSKI PROGRAM DRUGE STOPNJE RAČUNALNIŠTVO IN MATEMATIKA}\par}%
    \vfill\null%
    {\large \textsc{Mentor}: dr. Sergio Cabello \par}%
    {\vskip 2em \large Ljubljana 2017 \par}%
\end{center}
% prazna stran
\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%copyright stran
\thispagestyle{empty}
\vspace*{8cm}
{\small \noindent
Rezultati diplomskega dela so intelektualna lastnina avtorja in Fakultete za ma\-te\-ma\-ti\-ko in fiziko Univerze v Ljubljani. 
Za objavljanje ali izkoriščanje rezultatov di\-plom\-ske\-ga dela je potrebno pisno soglasje avtorja, Fakultete za ma\-te\-ma\-ti\-ko in 
fiziko ter mentorja.}


\begin{center} 
\mbox{}\vfill
\emph{Besedilo je oblikovano z urejevalnikom besedil \LaTeX.} 
\end{center}
% prazna stran
\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% stran 3 med uvodnimi listi
\noindent
Namesto te strani {\bf vstavite} original izdane teme diplomskega 
dela s podpisom mentorja in dekana ter žigom fakultete, ki ga diplomant
dvigne v študent\-skem referatu,  preden odda izdelek v vezavo!

% prazna stran
\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% izjava o avtorstvu
\vspace*{1cm}
\begin{center} 
{\Large \textbf{\sc Izjava o avtorstvu magistrskega dela}}
\end{center}

\vspace{1cm}
\noindent Spodaj podpisani Lazar Milinković,
z vpisno številko \textbf{27122037}, sem avtor magistrskega dela z naslovom:
   
\vspace{0.5cm}
\emph{Implementacija algoritmov za probleme najkrajših poti v geometrijskih grafih}

\vspace{1.5cm}
\noindent S svojim podpisom zagotavljam, da:
\begin{itemize}
	\item sem magistrsko delo izdelal samostojno pod mentorstvom 
		dr.\ Sergia Cabella,

	\item	so elektronska oblika magistrskega dela, naslov (slov., angl.), povzetek (slov., angl.) ter ključne besede (slov., angl.) identični s tiskano obliko magistrskega dela
	\item soglašam z javno objavo elektronske oblike diplomskega dela v zbirki ''Dela FRI''.
\end{itemize}

\vspace{1cm}
\noindent V Ljubljani, dne 11. januarja 2016 \hfill Podpis avtorja:

% prazna stran
\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% zahvala
\thispagestyle{empty}\mbox{}\vfill\null\it%
 
\rm\normalfont

% prazna stran
\clearemptydoublepage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% kazalo
\def\thepage{}% preprecimo tezave s stevilkami strani v kazalu 
\tableofcontents{}


% prazna stran
\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% povzetek 
\addcontentsline{toc}{chapter}{Povzetek}
\chapter*{Povzetek}
 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% abstract
\selectlanguage{english}
\addcontentsline{toc}{chapter}{Abstract}
\chapter*{Abstract}


\selectlanguage{slovene}
% prazna stran
\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mainmatter
\setcounter{page}{1}
\pagestyle{fancy}

\chapter{Uvod}
V magistrski nalogi smo obravnavali dva geometrijska optimizacijska problema na ravnini, pri katerih osrednjo vlogo predstavljajo enotski krogi. Predstavili smo učinkovita algoritma, ki rešita omenjena problema, opisali njuno implementacijo ter predložili rezultate eksperimentov.

Pri prvem problemu bi radi izračunali drevo najkrajših poti iz neuteženega grafa presekov enotskih krogov. Kot vhod je dana množica $\D$ $n$ krogov enake velikosti, kjer je vsak krog opisan z njegovim središčem. Vozlišča grafa presekov predstavljajo krogi, pri čemer med dvema vozliščema obstaja povezava natanko takrat, ko obstaja presečišče med njunima krogoma $D$ in $D'$. Graf presekov lahko predstavimo tudi na drug, bolj priročen način, kjer vozlišča predstavlja množica $P$ središč krogov, povezava med dvema točkama $p$ in $q$ pa obstaja, če je njuna evklidska razdalja $\|pq\|$ manjša ali enaka premeru enotskega kroga. Za podan koren $r \in P$ lahko iz takega grafa izračunamo drevo najkrajših poti brez eksplicitne izgradnje grafa, s čimer je časovna zahtevnost algoritma enaka $\OO(n\log n)$.

Drugi problem, ki ga obravnavamo, je problem minimalne ločitve. Kot vhod je dana množica $\D$ $n$ enotskih krogov na ravnini in dve točki $s$ in $t$, ki nista vsebovani v nobenem od krogov iz $\D$. Pravimo, da $\D$ ločuje $s$ in $t$, če vsaka pot v ravnini od $s$ do $t$ seka nek krog v $\D$. Cilj je najti minimalno kardinalno podmnožico množice $\D$, ki ločuje $s$ in $t$, kar formalno zapišemo kot 

\begin{align*}
	\min ~~		& |\D'|\\
	 \mbox{tako da}~~ & \D'\subset \D\\
				&	\D'\text{ ločuje $s$ in $t$}. 
\end{align*}

Polinomsko časovno zahtevnost algoritma $\OO(n^2log^3n)$ dosežemo tako, da za del rešitve uporabimo algoritem prvega problema za izgradnjo drevesa najkrajših poti. Oba problema sta tako povezana in ju je smiselno obravnavati skupaj.

Enotski krogi so najbolj standarden geometrijski model, ki se uporablja za brezžična senzorska omrežja (zanj se pogosto uporablja kratica UDG). Tak model predstavlja ustrezen kompromis med enostavnostjo in natačnostjo, saj je za bolj natančne modele dosti težje najti učinkovite algoritme. To pomeni tudi, da je izkoriščanje geometrijskih lastnosti modela UDG bolj zahtevno, algoritmi, ki se zanašajo na tak model, pa zaradi nerealističnih predpostavk pogosto odpovejo v praksi (kjer komunikacijski doseg ni idealen krog)~\cite{WGM06}. Drevesa najkrajših poti v grafu enotskih krogov igrajo pomembno vlogo pri usmerjanju in se pogosto uporabljajo pri bolj kompleksnih nalogah. Primer take uporabe v senzorskih omrežjih je pri algoritmu za prepoznavanje meja, ki tvorijo luknje s premalo senzorskimi vozlišči. Zaradi takih lukenj veliko požrešnih algoritmov za posredovanje paketov po omrežju odpove, ker predpostavljajo, da je omrežje dovolj gosto~\cite{FGG06}.

Problem minimalne ločitve je obravnavan že v~\cite{CG16}, kjer je podan tudi algoritem s časovno zahtevnostjo $\OO(n^3)$ v najslabšem primeru, ki deluje za poljubne like. Z omejitvijo likov na enotne kroge in uporabo več različnih orodij iz računske geometrije lahko zmanjšamo časovno zahtevnost, lažje izvedljiva pa postane tudi implementacija algoritma.

\begin{figure}
\centerline{\includegraphics[scale=0.6,page=4]{pics/unitdisks.pdf}}
\caption{Slikovna predstavitev problema. Točki $s$ in $t$ ločuje množica krogov, definiranih z njihovimi središčnimi točkami.}
\label{separation}
\end{figure}

V poglavju 2 je na kratko opisana programska knjižnica CGAL, ki smo jo uporabili pri implementaciji obeh algoritmov. Zanjo smo se odločili, ker omogoča dostop do že implementiranih različnih geometrijskih podatkovnih struktur. Pri opisu smo se osredotočili na osrednje ideje jedra knjižnice, na katerem temeljijo vsi ostali deli paketa, ter tiste strukture, ki so bile uporabljene pri implementaciji algoritmov. V poglavju 3 je predstavljen teoretični del algoritmov. Podrobno so opisane vse podatkovne strukture, celotna poteka algoritmov ter njuna časovna in prostorska kompleksnost. V poglavju 4 je predstavljena implementacija algoritmov. Ponovno so opisane vse uporabljene podatkovne strukture - tokrat z implementacijskega vidika - ter vse razširitve in spremembe, ki smo jih dodali h knjižnici CGAL. Podrobno so opisani tudi deli algoritmov, kjer se pojavijo razlike med teoretičnim opisom in implementacijo. V poglavju 5 so predstavljeni rezultati; prikazani so časi izvajanja in prostorska poraba celotnega algoritma za različno število vhodnih točk.

\clearemptydoublepage


\chapter{CGAL in uporabljene matematične strukture}
\label{ch1}

V tem poglavju so na kratko opisani programska knjižnica CGAL in podatkovne strukture, uporabljene v naših algoritmih. Za bolj podroben opis glej (citiraj van kreveld, cgal.org in nekaj za bfs, sssp in grid graf). Vse podatkovne strukture so opisane za dvodimenzionalni primer.
\section{CGAL}
CGAL (Computational Geometry Algorithms Library) je programski paket, ki omogoča enostaven dostop do učinkovitih in zanesljivih geometrijskih algoritmov v obliki C++ knjižnice. Uporablja se na različnih področjih, ki potrebujejo geometrijsko računanje, kot so geografski informacijski sistemi, računalniško podprto načrtovanje, molekularna biologija, medicina, računalniška grafika in robotika. Knjižnica vsebuje:

\begin{itemize}
\item jedro z geometrijskimi osnovami, kot so točke, vektorji, črte, predikati za preizkušanje stvari (na primer relativni položaji točk) in opravila, kot so izračunavanje presekov ter razdalj
\item osnovno knjižnico, ki je zbirka standardnih podatkovnih struktur in geometrijskih algoritmov, kot so konveksna ovojnica v 2D/3D, Delaunayova triangulacija v 2D/3D, ravninski zemljevid, polieder, Voronoijev diagram, območna drevesa (range trees) itd.
\item podporna knjižnica, ki ponuja vmesnike do drugih paketov, na primer za V/I in vizualizacijo. 
\end{itemize}

Ker cilj magistrske naloge ni bila implementacija osnovnih geometrijskih struktur, ki sicer predstavljajo pomembno osnovo našega algoritma, smo se odločili uporabiti omenjeno knjižnico in si s tem prihraniti čas in odvečno delo. Posledično je seveda celoten algoritem implementiran v jeziku C++.

Pri nekaterih razredih knjižnice smo morali spremeniti kodo ali dodati kaj novega. Podrobnosti so razložene v nadaljevanju opisa implementacije pri ustreznih delih algoritma.

??? 
natancnost: cartesian, kaj pa leda, homogenous?
povej kaj o traits, templated strukturami ($Point_2$) 
$https://doc.cgal.org/4.5/Kernel_23/classKernel.html$

\subsection{Številski tipi}
http://doc.cgal.org/latest/Number\U types/index.html\# Chapter\U Number\U Types
\subsection{Jedro knjižnice}
Jedro sestavljajo nespremenljivi geometrijski primitivni objekti konstantne velikosti (točke, vektorji, daljice, trikotniki...) ter funkcije in predikati, ki jih lahko kličemo nad njimi. Poleg tega ponuja osnovne operacije, kot so računanje razdalje, afina transformacija in zaznava presečišč. 

Eden od osnovnih problemov, s katerimi se soočimo pri implementaciji geometrijskih algoritmov, je eksaktno računanje z realnimi števili. Zaokroževanje pri uporabi aritmetike nad števili, predstavljenimi s plavajočo vejico, lahko privede do nekonsistentnih odločitev in nepričakovanih napakah že pri nekaterih osnovnih geometrijskih algoritmih. CGAL ponuja izbiro številskih tipov in aritmetike. Pri uporabi eksaktne aritmetike dobimo točne rezultate, a po drugi strani se čas izvajanja in prostorska poraba algoritma povečata.

\subsubsection{Predstavitev objektov jedra}
Vsi objekti jedra so predloge s parametrom, ki omogoča uporabniku izbiro predstavitve objektov. Dve družini modelov predstavitve temeljita na kartezični predstavitvi točk, dve pa na homogenični predstavitvi. Pri kartezični predstavitvi je vsaka točka predstavljena s kartezičnimi koordinatami, ki privzamejo $d$-dimenzionalni afini Evklidski prostor s koordinatnim izhodiščem in $d$ pravokotnimi osmi. Točke (in vektorji) so potem predstavljeni z $d$-terko $(c_o, c_1,..., c_{d-1})$. Pri homogeni predstavitvi so točke predstavljene z $(d+1)$-terko $(h_o, h_1,...,h_d)$. V kartezično predstavitev jih lahko pretvorimo s formulo $c_i = h_i/h_d$, ena od možnih homogenih predstavitev točke s kartezičnimi koordinatami pa je $(c_0, c_1,..., c_{d-1}, 1)$ (ker homogene koordinate niso enolične). Prednost uporabe homogenih koordinat v CGAL-u je, da se z njimi izognemo uporabi deljenja. Vmesnik objektov v jedru je napisan tako, da hkrati omogoča uporabo kartezične in homogene predstavitve. 

\paragraph{Številski tipi}
Obe družini predstavitve objektov sta nadalje parametrizirani s številskim tipom za koordinate. CGAL ponuja dva tipa predloge za številske tipe. Eden se nanaša na algebrsko strukturo kolobar, kjer je možno seštevati, odštevati in množiti, drugi pa na polje, kjer je poleg omenjenih operacij možno tudi deliti. Vgrajeni tip $int$ tako spada v prvo skupino, ker operacija deljenja ni inverz množenja.
leda, gmpz
(You might use limited precision integer types like int or long, use double to present your integers (they have more bits in their mantissa than an int and overflow nicely), or an arbitrary precision integer type like the wrapper Gmpz for the GMP integers, leda\U integer, or MP\U Float. )

\bigbreak
Če za vhodne podatke uporabljamo kartezične koordinate, bo veliko geometrijskih računanj vsebovalo samo vhodne vrednosti. To velja med drugim za taka računanja, ki vrednotijo predikate, pri katerih ne gre za nič drugega kot računanje determinante. Primeri so računanje triangulacije in konveksne ovojnice. V takih primerih je dovolj uporabiti kartezično predstavitev točk, celo s kolobarskim številskim tipom. Če pa algoritmi obsegajo tudi računanja novih točk, prihaja do uporabe deljenja, zato moramo uporabiti kartezično predstavitev s številskim tipom za polja, recimo $double$,  ali homogeno predstavitev. $double$ sicer ni popolnoma natančen, a ga ponavadi uporabljajo tisti, ki jim je pomembna hitrost in se zadovoljijo tudi s približnimi rezultati.

Algoritmi in podatkovne strukture v osnovni knjižnici CGAL so med drugim parametrizirani z razredom geometrijskih značilnosti, ki zajema objekte, nad katerimi algoritmi in strukture
delujejo. Za večino slednjih je dovolj za to uporabiti jedro.

\subsubsection{Geometrija in predikati jedra}
CGAL razlikuje med točkami, vektorji in smermi. Točka je točka v ekvklidskem prostoru $E^d$, vektor je razlika dveh točk $p_1, p_2$ ter označuje smer in razdaljo od $p_1$ do $p_2$ v vektorskem prostoru $\RR^d$, smer pa je vektor, pri katerem pozabimo na njegovo dolžino. Gre za različne matematične koncepte, ki se pri afinih transformacijah ne obnašajo enako.
Poleg tega so v CGAL-u na voljo premice, poltraki, daljice, ravnine, trikotniki, tetraedri,  krožnice, sfere, pravokotniki in kvadri.

Dve poljubni točki na premici definirata njeno orientacijo ter razdelitev ravnine na pozitivno in negativno stran. Poltrak je orientiran iz smeri njegovega končnega vozlišča, vozlišča daljic pa so urejena in definirajo isto orientacijo kot premica, na kateri daljice ležijo. Vsi geometrijski objekti imajo metodo za testiranje relativne lokacije dane točke glede na objekt. Ker so objekti in njihove meje predstavljene z istim tipom (na primer sfera in krogla ali krožnica in krog), svojo okolico razdelijo na omejen in neomejen del (krožnica) ali dva neomejena dela (hiperravnina). Vsi objekti so privzeto orientirani, kar pomeni, da je eden od delov označen kot pozitivna, drugi pa kot negativna stran. Prej omenjena metoda torej določa, ali se dana točka nahaja na pozitivni strani, negativni strani ali na meji objekta. 

\bigbreak
Predikati so osrčje jedra, saj predstavljajo osnovno enoto  pri izgradnji algoritmov, zato je njihova pravilnost ključnega pomena pri pravilni implementaciji. Predikati v CGAL-u ne vračajo nujno $boolean$ vrednosti, ampak tudi vrednosti tipa $enum$. Na voljo so predikati za orientacijo množice točk, primerjavo točk glede na dano zaporedje, primerjavo razdalj in testi za vsebovanost točke v krogu. Vse ostale metode, ki niso tipa $boolean$ ali $enum$, se imenujejo konstrukcije, ker vsebujejo računanja novih numeričnih vrednosti, ki so lahko nenatančna, če ni uporabljeno jedro z eksaktnim številskim tipom. Primer take metode, ki je na voljo za večino geometrijskih objektov, je afina transformacija. Druga dva tipična primera sta računanje presečišč med objekti in kvadrata razdalje.

\section{Kd drevesa}

\begin{figure}		
\centerline{\includegraphics[scale=1.2]{pics/kdTree4.pdf}}		
\caption{Dvodimenzionalno kd drevo.}		
\label{kd-primer}		
\end{figure}
Kd drevo je podatkovna struktura za organiziranje k-dimenzionalnih točk z razbitjem prostora. Najpogosteje se uporablja za območna iskanja in iskanja najbližjih sosedov.
Kd drevo je v osnovi binarno drevo, kjer vsako notranje vozlišče razdeli prostor na dva polprostora (polravnini), ki ju ločuje hiperravnina (premica). Točke levo od hiperravnine so vsebovane v levem poddrevesu vozlišča, točke desno od hiperravnine pa v desnem poddrevesu. Smer hiperravnine je odvisna od tega, po kateri dimenziji vozlišče razdeli prostor.
Za i-ti nivo drevesa velja, da je hiperravnina, ki razdeli prostor, pravokotna na koordinatno os, ki predstavlja $j = ((i-1) mod k + 1)$-to dimenzijo prostora. Vozlišče na drugem nivoju dvodimenzionalnega kd drevesa tako razdeli
ravnino s premico, ki je vzporedna abscisni osi. Točke v spodnji polravnini se nahajajo v levem poddrevesu vozlišča, točke v zgornji polravnini pa v desnem poddrevesu. Hiperravnina, ki jo predstavlja neko vozlišče $v$ v $i$-tem nivoju,
gre skozi tisto točko, čigar $j$-ta koordinata predstavlja mediano v množici vseh točk, ki se nahajajo v drevesu s korenom. Točke so shranjene v listih drevesa.

Časovna zahtevnost izgradnje drevesa je $\OO(n\log n)$ (na vsakem nivoju drevesa je potrebno izračunati mediano, kar vzame $\OO(n)$ časa), prostorska zahtevnost drevesa pa $\OO(n)$~\cite{bkos-08}.
\subsection{Poizvedbe}
Časovna zahtevnost poizvedbe je $\OO(n^{(1-\frac{1}{d})} + k)$, kjer je $k$ število poročanih točk. V splošnem za dvodimenzionalno kd drevo velja, da je območje $reg(v)$, ki ga predstavlja vozlišče $v$, pravokotnik, ki je lahko neomejen z več strani. Omejen je s hiperravninami (premicami), shranjenih v starših $v$. Točka je vsebovana v drevesu s korenom $v$, če je vsebovana v $reg(v)$. Drevo s korenom $v$ med poizvedbo obiščemo le, če poizvedbeno območje (pravokotnik) seka $reg(v)$. Če
je $reg(v)$ v celoti vsebovana v poizvedbenem območju, v rezultat dodamo celotno poddrevo $v$. Če pridemo do lista, preverimo, če je vozlišče shranjeno v njem vsebovano v območju. Primer poizvedbe je prikazan na sliki ~\ref{kd-primer} (pri čemer je treba opozoriti, da pri drevesu na sliki za razdelitev prostora ni bila vedno izbrana mediana).

\subsection{Kd drevesa v CGAL-u}


\section{Drevesa najkrajših poti z eno izvorno točko (SSSP)}
Drevo najkrajših poti z eno izvorno točko je vpeto drevo $T$ grafa $G$ s korenom $v$, za katerega velja, da je razdalja poti od $v$ do $u \in T$ enaka razdalji najkrajše poti od $v$ do $u$. Tako drevo lahko zgradimo s pomočjo algoritma za iskanje najkrajše poti med dvema danima točkama (tipična primera sta Dijkstrov in Bellman-Fordov algoritem). Izvorno točko $v$ fiksiramo in poženemo algoritem za vse pare $(v, u), v,u \in G.$ Časovna kompleksnost Dijkstrovega algoritma je $\OO((m+n)\log n)$, kjer je $n$ število vozlišč, $m$ pa število povezav v $G$. Ker moramo algoritem pognati za $n-1$ parov, lahko drevo zgradimo v času $\OO((n^2 + nm)\log n)$. Če predpostavimo, da za vhodni graf $G$ veljajo določene omejitve (v primeru našega algoritma povezava med vozliščema v grafu obstaja samo, če je njuna razdalja največ 1), ki se jih da izkoristiti pri izgradnji hitrejšega algoritma, se časovna kompleksnost lahko izboljša.
\section{Graf kvadratne mreže}
\label{grid-chapter}
Dvodimenzionalni graf kvadratne mreže je $m \times n$ mrežni graf $G_{m,n}$, ki predstavlja kartezični produkt dveh grafov poti z $n-1$ in $m-1$ povezavami. Vsi mrežni grafi so dvodelni, kar se da enostavno pokazati s tem, da se vozlišča pobarva z dvema barvama z vzorcem šahovnice.


Vozlišča grafa ponavadi sovpadajo s točkami v ravnini, pri katerih koordinate predstavljajo cela števila: abscisne koordinate imajo vrednosti 1,...,n, ordinatne pa 1,...,m. Dve vozlišči sta povezani, če je njuna razdalja enaka 1, zato takemu grafu pravimo tudi graf enotskih razdalj.


\section{Delaunayeva triangulacija}
Delaunayeva triangulacija nad točkami $P$ je triangulacija $DT(P)$, ki izpolnjuje Delaunayev pogoj. Ta pravi, da se nobena točka iz $P$ ne nahaja znotraj očrtanega kroga poljubnega trikotnika triangulacije. Taka triangulacija
maksimizira minimalni kot med vsemi koti trikotnikov. Množica $P$ s kolinearnimi točkami predstavlja izrojen primer, za katerega ne obstaja nobena Delaunayeva triangulacija. Če točke v $P$ ležijo na istem krogu, rešitev ni enolična.

Med točko $p$ in njenim najbližjim sosedom $q$, kjer $p,q\in P$, vedno obstaja povezava $pq\in E(DT(P))$, ker je graf najbližjih sosedov nad množico $P$ podgraf Delaunayeve triangulacije. Za dolžino najkrajše poti $dist(\pi (p,q))$ med dvema 
vozliščema $p,q$ v Delaunayevem grafu velja:

\begin{equation}
dist(\pi (p,q)) \leq 2.418\times dist(p,q).
\end{equation}

Za izgradnjo triangulacije poznamo več algoritmov. Najpogosteje uporabljeni so: 

\begin{description}
\item[algoritem z obračanjem] Pomembna lastnost dveh trikotnikov ABD in BCD s skupno stranico BD v Delaunayevi triangulaciji je, da je vsota kotov $\alpha$ in $\gamma$ manjša od 180\textdegree. Če ta lastnost ne velja, jo lahko dosežemo z obračanjem trikotnikov, tako da dobimo trikotnika ABC in ACD s skupno stranico AC. Algoritem z obračanjem zgradi navadno triangulacijo, nato pa izvaja operacijo obračanja, dokler vsi trikotniki ne izpolnjujejo Delaunayevega pogoja. Časovna zahtevnost v najslabšem primeru je $\OO(n^2)$.
\item[inkrementalni algoritem z vstavljanjem] Dodaja točke zaporedoma v obstoječo triangulacijo. Ko je nova točka dodana, se tiste dele Delaunayevega grafa, na katere nova točka vpliva, popravi z obračanjem trikotnikov. V najslabšem primeru je časovna zahtevnost algoritma $\OO(n^2)$, ker moramo za vsako dodano točko najti trikotnik, ki jo vsebuje ($\OO(n)$), in popraviti vse trikotnike ($\OO(n)$). Z nekoliko izboljšanim algoritmom za iskanje lokacije nove točke je pričakovana časovna zahtevnost $\OO(n\log n)$, ker je v povprečju v vsakem koraku obrnjenih $\OO(1)$ trikotnikov, iskanje lokacije nove točke pa vzame v povprečju $\OO(\log n)$ časa.
\item[deli in vladaj] Točke so rekurzivno razdeljene v dve množici z določeno premico. Delaunayeva triangulacija je izračunana za vsako množico točk posebej, nato pa sta obe triangulaciji združeni vzdolž premice. Združevanje vzame $\OO(n)$ časa, tako da je časovna zahtevnost algoritma $\OO(n\log n)$. V praksi je deli in vladaj najhitrejši algoritem za izgradnjo Delaunayeve triangulacije.
\end{description}

\subsection{Delaunayeva triangulacija v CGAL-u}
Razred Delaunay\U triangulation\U 2 implementira Delaunayevo triangulacijo in deduje iz razreda Triangulation\U 2. Iz slednjega uporablja nekatere metode, kot so vstavljanje ali lociranje točke, nekatere pa tudi povozi, kot je recimo obračanje trikotnikov, ker trikotnikom v navadni triangulaciji ni potrebno izpolnjevati Delaunayevega pogoja. Poleg tega vsebuje dodatne metode za iskanje najbližjega soseda in konstrukcijo elementov Delaunayi triangulaciji dualnega Voronoijevega diagrama.

Razred je parametriziran z dvema predlogama; prvi je razred geometrijskih značilnosti, drugi pa razred podatkovne strukture za triangulacijo. Za slednjega CGAL ponuja privzeti razred Triangulation\U data\U structure\U 2, ki vsebuje zbirki vozlišč in lic. Razred geometrijskih značilnosti mora biti model koncepta DelaunayTriangulationTraits\U 2, ki je dodelana verzija koncepta TriangulationTraits\U 2. Ta vsebuje predikata za primerjavo koordinat dveh točk in test orientacije treh točk. DelaunayTriangulationTraits\U 2 dodatno vsebuje še predikat side\U of\U oriented\U circle, ki za štiri dane točke $p, q, r, s$ določi položaj točke $s$ glede na krožnico, ki gre skozi točke $p, q$ in $r$.

Izgradnja triangulacije uporablja inkrementalni algoritem z obračanjem. 

\subsubsection{Operacije nad strukturo}
\begin{description}
\item[lociranje točke] Je implementirano s sprehodom po povezavah. Sprehod se začne pri vozlišču podanega lica, ali pri naključnem vozlišču, če lice ni podano. Povprečna časovna zahtevnost je $\OO(\sqrt{n})$.
\item[vstavljanje nove točke] Najprej je uporabljena metoda $locate$ za lociranje lica, ki vsebuje novo točko, nato pa se lice razbije na tri dele. Novo triangulacijo se nato popravi z $\OO(d)$ obračanji (v povprečju $\OO(1)$), kjer je $d$ stopnja novega vozlišča
\item[iskanje najbližjega soseda] Uporabljena je metoda $locate$, nato pa je potrebnega $\OO(1)$ časa za najdbo najbližjega soseda pri enakomerno porazdeljenih vozliščih, v najslabšem primeru pa $\OO(n)$ časa.
\end{description}

\subsubsection{Hierarhija triangulacij}
Za učinkovito lociranje točk lahko uporabimo razred Triangulation\U hierarchy\U 2, ki hrani hierarhijo triangulacij. Na najnižjem nivoju se nahaja izvirna triangulacija, nad katero se izvajajo operacije in lociranje točk. Na vsakem višjem nivoju je nato zgrajena triangulacija nad manjšo množico naključno izbranih vozlišč iz triangulacije na predhodnem nivoju (recimo 3\% vozlišč). Lociranje točke se izvede od zgoraj navzdol po strukturi: na najvišjem nivoju se naivno izvede poizvedba najbližjega soseda, nato pa se na vsakem naslednjem nivoju najde najbližjega soseda s sprehodom po povezavah z začetkom pri najbližjem sosedu, najdenem na višjem nivoju. Taka struktura je najbolj primerna ravno za Delaunayeve triangulacije. Poleg hitrega delovanja na realnih podatkih ima dobro časovno zahtevnost v najslabšem primeru, in nizko prostorsko kompleksnost~\cite{Olivier}.

\section{Voronoijev diagram}
\begin{figure}
\centerline{\includegraphics[scale=0.8]{pics/voronoi-dt2.pdf}}
\caption{Evklidski Voronoijev diagram brez degeneracij, označen z rdečimi odebeljenimi povezavami. Voronoijeva središča, obarvana z modro barvo, predstavljajo hkrati tudi vozlišča v Delaunayevi triangulaciji, dualni Voronoijevemu diagramu, in je označena s tanjšimi črnimi povezavami.}
\label{vd}
\end{figure}

Voronoijev diagram ~\cite{cgal:k-vda2-15a} je definiran na množici točk, imenovanih Voronoijeva središča (angleško $sites$), ki ležijo v nekem prostoru $\sum$, in z metriko oziroma funkcijo razdalje med točkami. Za ravninski Voronoijev diagram, opisan v nadaljevanju, velja $\sum = \mathbb{R}^2$.

Naj bo S = $S = \{S_1,S_2,...,S_n\}$ množica Voroijevih središč in naj bo $\delta(x,S_i)$ funkcija razdalje med središčem $S_i$ in neko točko $x \in \mathbb{R}^2$. Množica točk $V_{ij}$, ki so bližje središču $S_i$ kot središču $S_2$ na podlagi funkcije $\delta(x,\cdot)$, je množica:

\begin{equation}
V_{ij} = \{x \in \mathbb{R}^2: \delta(x,S_i) < \delta(x,S_j)\}. 
\end{equation}

Množico $V_i$ točk, ki so bližje središču $S_i$ kot kateremu koli drugemu središču, lahko potem definiramo kot množico:

\begin{equation}
V_i = \bigcap_{i \neq j} V_{ij} .
\end{equation}



Množico $V_i$ imenujemo tudi Voronoijeva celica ali Voronijevo lice središča $S_i$. Lokus točk, ki so enako oddaljene od dveh središč, se imenuje Voronijev bisektor. Povezani podmnožici slednjega pravimo Voronoijev rob. Točki, ki je enako oddaljena od treh ali več središč, pravimo Voronoijevo vozlišče. Voronoijev diagram na množici $S$ in z metriko $\delta(x,\cdot)$ je zbirka Voronoijevih celic, robov in vozlišč ter je primer ravninskega grafa.

Celice si ponavadi predstavljamo kot 2-dimenzionalne, robove kot 1-dimenzionalne in vozlišča kot 0-dimenzionalne objekte. Za določene kombinacije središč in metrik to ne drži. Voronijev diagram z metriko $L_1$ ali $L_{\infty}$ lahko na primer vsebuje dvodimenzionalne robove. Takim Voronoijevim diagramom, za katere zgornja omejitev drži in imajo lastnost, da so njihove celice preprosto povezano območje v ravnini, pravimo preprosti Voronoijevi diagrami. Najbolj tipičen primer slednjih je evklidski Voronoijev diagram (slika ~\ref{vd}), ki ga uporabljamo v našem algoritmu.

\subsection{Voronoijev diagram v CGAL-u}
Knjižnica CGAL vsebuje razred Voronoi\texttt{\_}diagram\texttt{\_}2$<DG,AT,AP>$, ki deluje kot prilagoditveni paket. Ta Delaunayevo triangulacijo na podlagi podanih kriterijev prilagodi pripadajočemu Voronoijevemu diagramu, ki je predstavljen kot DCEL (doubly connected edge list) struktura. Paket je torej zasnovan tako, da na zunaj deluje kot DCEL struktura, znotraj pa v resnici hrani strukturo grafa, ki predstavlja graf triangulacije.

Razred je parametriziran s tremi predlogami. Prvi, DT, mora biti model koncepta razreda DelaunayGraph\texttt{\_}2. Primeri takih struktur so Delaunayeva triangulacija, navadna triangulacija, Apollonov graf in hierarhija triangulacij. Druga predloga, AT, predstavlja lastnosti pretvorbe Delaunayeve triangulacije v Voronoijev diagram ter definira tipe struktur in funktorje, ki jih razred potrebuje za dostop do geometrijskih lastnosti Delaunayeve triangulacije. Funktor mora biti recimo definiran za konstrukcijo Voronoijevih vozlišč iz njihovih dualnih lic v Delaunayevi triangulaciji. Za našo implementacijo algoritma ločevanja z diski je pomemben funktor za poizvedbe najbližjih središč, ki kot rezultat vrne informacijo o tem, koliko in katera središča so enako oddaljena od točke poizvedbe. Bolj konkretno, rezultat je Delaunayevo vozlišče, lice ali rob, na katerem točka poizvedbe leži oziroma z njim sovpada. Če je na primer točka poizvedbe $q$, enako oddaljena od treh središč, potem sovpada z nekim Voronoijevim vozliščem, zato funktor vrne Delaunayevo lice, ki je dualno temu vozlišču. Razred, ki predstavlja Delaunayevo lice, omogoča iteracijo po Delaunayevih vozliščih, ki definirajo lice, ta pa so dualna trem Voronoijevim središčem.

Tretja predloga predstavlja režim adaptacije Delaunayeve triangulacije Voronoijevemu diagramu. 
Če množica središč, ki določa graf Delaunayeve triangulacije, vsebuje podmmnožice središč, ki so v izrojenem položaju, ima dualni graf - Voronoijev diagram - lahko robove dolžine nič in po možnosti tudi celice s ploščino nič. Režim adaptacije določa, kaj storiti v takih primerih. V našem projektu smo uporabili režim Delaunay\U triangulation\U caching\U degeneracy\U removal\U policy\U 2. Kot pove že ime, ta tip poskrbi, da so vse zgoraj opisane celice in robovi odstranjeni iz Voronoijevega diagrama. Poleg tega uporablja $cache$ pri ugotavljanju, ali ima določena celica oziroma rob degenerirane lastnosti. Ker je slednje precej zahtevna operacija, se ta tip izplača pri vhodnih podatkih (središčih) z veliko izrojenimi primeri.
 
\section{Območna drevesa}
Območna drevesa so še ena podatkovna struktura za poizvedbe nad pravokotnimi območji. V primerjavi s kd drevesi imajo boljši čas poizvedbe ($\OO(\log^2 n + k)$), ampak slabšo prostorsko kompleksnost ($\OO(n\log n)$). Namesto, da razdelimo prostor izmenično po abscisni in ordinatni osi, imamo tukaj kot glavno drevo uravnoteženo dvojiško iskalno drevo $\T$, zgrajeno nad $x$ koordinatami točk. Vsako vozlišče $v$ drevesa ima potem kazalec na uravnoteženo dvojiško iskalno poddrevo $\T_{assoc}(v)$, zgrajeno nad $y$ koordinatami točk, ki so shranjene v listih poddrevesa v $\T$ s korenom $v$.

Poizvedba $[x:x'] \times [y:y']$ v taki strukturi poteka na sledeč način: v glavnem drevesu iščemo z intervalom $x:x'$, dokler ne pridemo do vozlišča $v_{split}$, kjer se iskanje razcepi na dva dela. Iskanje nadaljujemo v smeri njegovega levega otroka in pri vsakem obiskanem vozlišču $v$, kjer se pot iskanja nadaljuje levo, označimo njegovega desnega otroka. Podobno nadaljujemo v smeri desnega otroka vozlišča $v_{split}$ in označimo levega otroka obiskanega vozlišča $v$, pri katerem se iskanje nadaljuje v desno. 
V tem trenutku imamo označenih $\OO(\log n)$ poddreves. Za vsako poddrevo s korenom $v$ $P(v)$ naredimo poizvedbo $[y:y']$ na sekundarnem drevesu $\T_{assoc}(v)$, ki hrani vse točke iz $P(v)$. 

Dejanske točke so shranjene v drevesih $\T_{assoc}$. Na danem nivoju drevesa $\T$ je neka točka $p \in P$ shranjena v natanko enem drevesu $\T_{assoc}$. Iz tega sledi, da vsa drevesa $\T_{assoc}$ na poljubnem nivoju drevesa $T$ porabijo skupaj $\OO(n)$ prostora. Ker je globina drevesa $\T$ $\OO(\log n)$, je prostorska zahtevnost območnih dreves $\OO(n\log n)$.

Časovna zahtevnost enodimenzionalne poizvedbe v poddrevesu $\T_{assoc}(v)$ je $\OO(\log n + k_v)$, kjer je $k_v$ število vrnjenih točk. Celotni čas poizvedbe je $\sum_v\OO(\log n + k_v)$, torej vsota vseh obiskanih vozlišč v $T$. Ker je dolžina obeh iskalnih poti (ki se razcepita pri vozlišču $v_{split}$) enaka $\OO(\log n)$, in je vsota $\sum_v k_v$ enaka številu vseh vrnjenih točk poizvedbe $k$, je časovna zahtevnost celotne poizvedbe $\OO(log^2n + k)$.

\subsection{Območna drevesa v CGAL-u}
Vhodni podatkovni tip za $d$-dimenzionalno območno drevo je zbirka, ki vsebuje podatkovni tip za $d$-dimenzionalno točko in opcijsko tip vrednosti, s katerim lahko shranimo poljubni podatek. Primer uporabe slednjega bi lahko bila množica točk, ki sestavljajo več večkotnikov. Vsako vozlišče drevesa bi potem kot ključ shranilo neko točko, kot vrednost pa poligon, kateremu ta točka pripada. 

Razred za območno drevo je popolnoma generičen, kar pomeni, da z njim lahko definiramo večnivojska drevesa. $d$-dimenzionalno večnivojsko drevo  (z $d$ nivoji) je na $d$-tem nivoju preprosto drevo, $k$-ti nivo, $1 \leq k \leq d-1$, pa drevo, kjer vsako notranje vozlišče vsebuje večnivojsko drevo dimenzije $d-k+1$. $k-1$-dimenzionalno drevo, ki je vgnezdeno drevo v $k$-dimenzionalnem drevesu \T, imenujemo podnivojsko drevo drevesa \T. 


Razred je neodvisen tako od vrste podatkov kot od njihove konkretne predstavitve. Za tako splošnost moramo definirati, kako je predstavljeno drevo na vsakem nivoju in kako so vhodni podatki organizirani. Drevesa z dimenzijo $k$, $ 1 < k < 4$, so zato v CGAL-u definirana v lastnih razredih, pripravljenih za takojšnjo uporabo. Ko je drevo enkrat zgrajeno, dodajanje ali brisanje podatkov iz njega ni več mogoče.

\bigbreak
Drevo je parametrizirano s tremi predlogami: podatki, oknom in geometrijskimi značilnostmi. Prvi definira vrsto podatkov, drugi poizvedbeno območje, tretji pa podajajo implementacijo metod, ki jih drevo uporablja za dostop do podatkov. Da bi se izognili uporabi vgnezdenih predlog za argumente (do česar pride, če bi drevo na vsakem nivoju imelo predlogo za tip poddrevesa), so drevesa definirana s pomočjo objektnega programiranja. CGAL je definiral virtualni bazni razred $Tree\U base$, iz katerega je izpeljan razred $Range\U tree\U d$. Konstrukturju slednjega moramo kot argument podati prototip poddrevesa tipa $Tree\U base$, ki je lahko zopet objekt razreda $Range\U tree\U d$. Za zaustavitev rekurzije je iz $Tree\U base$ izpeljan še razred $Tree\U anchor$, čigar konstruktor ne pričakuje nobenega argumenta. Tako opisana konstrukcija sledi modelu prototipa in v njej je poddrevo definirano s pomočjo objektnega programiranja v času izvajanja programa, kar pa predstavlja zanemarljiv časovni strošek.

\begin{figure}
\centerline{\includegraphics[scale=1]{pics/rangeTree2.pdf}}
\caption{Dvodimenzionalno območno drevo.}
\label{range-primer}
\end{figure}


\chapter{Teorija}
Naj bo $P$ množica točk, ki predstavljajo središča krogov $\D$. $P$ predstavlja vhod našega algoritma in vse operacije ter uporabljene podatkovne strukture se vrtijo okoli te množice. Kardinalnost množice je enaka $n$.

\begin{figure}
\centerline{\includegraphics[scale=0.6,page=5]{pics/unitdisks.pdf}}
\caption{Graf $G(P)$, zgrajen nad množico $P$ v sliki ~\ref{separation}.}
\label{gdisks}
\end{figure}

Naj bo $G(P)$ graf z množico vozlišč $P$ s povezavo med točkama $p,q \in P$, če velja $|pq| <= 1$ z evklidsko metriko. Vse povezave so neobtežene.

\begin{figure}
\centerline{\includegraphics[scale=0.6,page=3]{pics/separation.pdf}}
\caption{Minimalna podmnožica točk iz slike ~\ref{separation}, ki ločuje $s$ in $t$, med seboj povezanih z modrimi povezavami. Podmnožica je vedno zaprta pot.}
\label{walk}
\end{figure}

V nadaljevanju bomo namesto $G(P)$ pisali preprosto $G$, brez izgube splošnosti pa predpostavili, da je $z=(0,0)$ in $z'=(0,s)$. $zz'$ je torej daljica, v nadaljevanju imenovana $\sigma$, ki je vsebovana v koordinatni osi $y$. Če dana vhodna daljica ne leži na osi $y$, lahko naredimo translacijo nad $\sigma$ in $P$. Ce daljica ni niti navpična, lahko naredimo tudi rotacijo daljice in točk, kjer pa je treba upoštevati, da pri tem pride do numeričnih napak in se prave razdalje med točkami izgubijo. 
\section{Drevo SSSP}
\subsection{Eksplicitna uporaba preiskovanja v širino (BFS)}
\begin{figure}[htb]
\begin{center}
\ovalbox{~~~~
\begin{varwidth}{\linewidth}
\begin{codebox}
    \Procname{$\proc{BFS}(G,s)$}
    \li // za vsako povezavo $e\in G.E$ velja $dist(e) \leq 1$ 
    \li \For $u\in G.V - \{s\}$ \Do
    	\li $u.visited \gets$ false
    	\li $u.dist \gets \infty$
    	\li $u.\pi \gets$ NIL
    \End
    \li $s.visited =$ true
    \li $u.dist = 0$
    \li $u.\pi =$ NIL
    \li $Q = \emptyset$
    \li enqueue($Q, s$)
    \li \While $Q \neq \emptyset$ \Do
    	\li $u =$ dequeue($Q$)
    	\li \For $(u,v) \in G.E$ \Do
    		\li \If $v.visited ==$ false \Do
    			\li $v.visited =$ true
    			\li $v.dist = u.dist + 1$
    			\li $v.\pi = u$
    			\li enqueue($Q, v$)
    		\End
    	\End
	\End
    \\[-2mm]
\end{codebox}
\end{varwidth}
~~~~}\end{center}
\caption{Psevdokoda eksplicitnega (splošnega) algoritma za preiskovanje v širino in posledično izgradnjo drevesa najkrajših poti.}
\label{fig:genericBfs}
\end{figure}
\afterpage{\FloatBarrier}
\subsection{BFS z uporabo grafa kvadratne mreže}
\begin{figure}
\centerline{\includegraphics[scale=1.2]{pics/grid.pdf}}
\caption{.}
\label{grid}
\end{figure}
\afterpage{\FloatBarrier}
Graf enotske kvadratne mreže je med drugim uporaben za preiskovanje v širino kot alternativa klasičnemu algoritmu BFS nad grafom enotskih razdalj. Vsaki točki iz dane množice $P$ lahko izračunamo njen ključ tako, da poiščemo spodnje levo vozlišče celice grafa kvadratne mreže, v kateri se točka nahaja (glej sliko ~\ref{grid}). Graf $G(P)$ lahko tako predstavimo s slovarjem, kjer ključi predstavljajo vozlišča grafa kvadratne mreže, kot vrednosti pa hranijo seznam vseh točk v celici, ki se nahaja zgoraj desno od ključa. Preiskovanje v širino nad takim grafom poteka tako, da za dano točko preverimo samo tiste kandidate, ki se nahajajo v isti ali eni izmed sosednjih celic grafa kvadratne mreže, točki pa povežemo, če je njuna razdalja največ 1. 

\subsection{Prilagojen algoritem za enotske diske}
\label{sssp-true}
V tem poglavju je opisan algoritem za drevo SSSP (ang. single source shortest path). Gre za preiskovanje v širino nad grafom $G(P)$ brez dejanske izgradnje grafa. Vhod algoritma je torej $P$, pri izgradnji drevesa pa se uporablja abstrakten graf G(P).

\begin{figure}
\centerline{\includegraphics[scale=0.6,page=6]{pics/unitdisks.pdf}}
\caption{Drevo najbližjega soseda, ki hrani 6 točk, predstavljeno v obliki seznama. Za vsako celico so prikazani indeksi točk, ki jih hrani objekt v njej.}
\label{nnarray}
\end{figure}

Algoritem dobi kot vhod poleg množice $P$ izvorno točko $s\in P$ in nato inkrementalno v vsaki iteraciji dodaja točke h grafu. Množico točk, dodanih k drevesu v $i$-ti iteraciji, označimo kot
\[	W_i = \{ p\in P \mid d_{G(P)}(s,p) = i\}.
	\]

Velja torej $W_0 = \{s\}$. Za izgradnjo $W_i$ ne potrebujemo celotnega grafa, zgrajenega do $i-1$-te iteracije, temveč samo množico $W_{i-1}$.  Za vsak $q\in W_i$ velja, da je povezan s točko $p = NN(q, W_{i-1})$. $p$ je torej izmed točk v $W_{i-1}$ najbližje $q$.

Pri izgradnji $W_i$ ne pregledujemo vseh še ne dodanih točk. Že v samem začetku najprej zgradimo Delaunayevo triangulacijo $DT(P)$, ki nam je v pomoč pri iskanju primernih kandidatov za $W_i$. To so:

\begin{itemize}
\item točke sosednje $W_{i-1}$ v $DT(P)$
\item točke sosednje (do tega trenutka zgrajeni) $W_i$ v $DT(P)$.
\end{itemize} 

\begin{lema}
\label{lema1}
Naj bo $p$ točka v $P\backslash \{s\}$, za katero velja $d(s,p) < \infty$. Obstajata točka $w$ v $P$ in pot $\Pi$ v $DT(P)$ od $w$ do $p$, za kateri velja $d(s,w)+1 = d(s,p)$ in $d(s,p_j) = d(s,p)$ za vsako notranje vozlišče $p_j$ v $\Pi$.
\end{lema}

\begin{figure}
\centerline{\includegraphics[scale=1]{pics/path.pdf}}
\caption{aa}
\label{c1c2}
\end{figure}

\begin{proof}
Naj bo $i = d(s,p)$, $w$ pa naj bo točka z $d(s,w) = i - 1$, ki je najbližje $p$ po evklidski razdalji. Ker $d(s,p) < \infty$, mora veljati $\|w - p\| \leq 1$. Naj bo $D_{wp}$ krog s premerom $wp$.

Predpostavimo, da segment $wp$ ne gre skozi nobeno vozlišče VD nad $P$.  Pobliže si poglejmo zaporedje Voronoijevih celic $cell(p_1, P),..., cell(p_k, P)$, ki ga seka segment $wp$, ko se sprehodimo od $w$ do $p$. Očitno velja $w = p_1$ in $p = p_k$. Za vsak $1 \leq j < k$ je povezava $p_jp_{j+1}$ v $DT(P)$, ker sta si celici $cell(p_j, P)$ in $cell(p_{j+1}, P)$ sosedni prek neke točke v $wp$. Pot $\pi = p_1p_2...p_k$ je zato vsebovana v $DT(P)$ in povezuje $w$ s $p$. Za katerikoli indeks $j$, kjer $1 < j < k$, naj bo $a_j$ katerakoli točka v $wp \cap cell(p_j, P)$. Ker velja $\|a_jp_j\| \leq \{\|a_jw\|, \|a_jp\|\}$, je točka $p_j$ vsebovana v $D_{wp}$. Potem je celotna pot $\pi$ vsebovana v $D_{wp}$, in ker je premer $D_{wp}$ največ 1, je vsaka povezava poti $\pi$ tudi v $G(P)$. S tem sklenemo, da je $\pi$ pot v $DT(P) \cap G(P)$.

Vzemimo katerokoli točko $p_j$ v $\pi$, ki je potem vsebovana v $D_{wp}$. Ker $\|w - p_j\| \leq \|w - p\| \leq 1$, velja $d(s, p_j) \leq d(s, w) + 1 = i$. Ker $\|p_j - p\| \leq \|w - p\| \leq 1$, velja $d(s, p_j) \geq d(s, p) - 1 = i - 1$. Ampak izbira $w$ kot točke najbližje $p$ pomeni, da $d(s, p_j) \neq i - 1$, ker $\|p_j - p\| < \|w - p\|$. Zato velja $d(s, p_j) = i$. Iz tega sklenemo, da za vsa notranja vozlišča $p_j$ v $\pi$ velja $d(s, p_j) = i$. 
\end{proof}

\begin{lema}
\label{lema2}
Na koncu algoritma $UnweightedShortestPath(P, s)$ velja:

\begin{equation}
\forall i \in \NN \cup \{0\}:  W_i = \{p\in P \mid d(s, p) = i\}.
\end{equation}

Poleg tega za vsako točko $p \in P \backslash \{s\}$ velja $dist[p] = d(s,p)$ in če velja $d(s,p) < \infty$, potem obstaja najkrajša pot v $G(P)$ od $s$ do $p$, v kateri je zadnja povezava $\pi [p]p$.
\end{lema}

\begin{proof}
Za dokaz uporabimo indukcijo nad $i$. $W_0 = \{s\}$ je nastavljen v vrstici 6 in kasneje ne spremeni vrednosti. Za $i = 0$ potem izjava velja.

Preden obravnavamo indukcijski korak, izpostavimo, da so množice $W_0, W_1,...$ parno disjunktne. To je razvidno tudi iz psevdokode. Točka $p$  je v vrstici 21 dodana v nek $W_i$, po tem, ko nastavimo $dist[p] = i$ v vrstici 18. Po tem je pogoj v vrstici 17 vedno neresničen in $p$ ni dodan v nobeno drugo množico $W_j$.

Vzemimo katerikoli $i \ge 0$. Po indukcijski predpostavki velja

\begin{equation}
W_{i-1} = \{p \in P \mid d(s,p) = i - 1\}.
\end{equation}

V algoritmu dodamo točke v $W_i$ samo v vrstici 21. Če je $p$ dodan v $W_i$, potem velja $\|p - w\| \leq 1$ za nek $w \in W_{i-1}$ zaradi pogoja v vrstici 17. Potem vsak $p$, dodan v $W_i$, zadostuje pogoju $d(s,p) \leq i$. Ker $p \notin W_{i-1}$, iz disjunkcije množic $W_0, W_1,...$ sledi $d(s,p) = i$. Sklenemo, da

\begin{equation}
W_i \subseteq \{p \in P \mid d(s,p) = i\}.
\end{equation}

Da dobimo vsebovanost v drugo smer, naj bo $p$ neka točka, za katero velja $d(s,p) = i$. Pokazati moramo, da je z algoritmom $p$ dodan v $W_i$. Vzemimo točko $w$ in pot $\pi = p_1...p_k$, zagotovljeno z lemo ~\ref{lema1}. Z indukcijsko hipotezo imamo $w = p_1 \in W_{i-1}$ in zato je $w$ dodan v $Q$ v vrstici 10. V nekem trenutku je povezava $p_1p_2$ obravnavana v vrstici 15 in točka $p2$ je dodana v $W_i$ in $Q$. Po $indukcijski tezi$(!!!) so potem vse točke $p_3,...,p_k$ dodane v $W_i$ in $Q$ (po možnosti v različnem vrstnem redu). Sledi, da je $p_k = p$ dodan v $W_i$ in zato

\begin{equation}
W_i = \{p \in P \mid d(s,p) = i \}.
\end{equation}

Ker je $p$ dodan v $W_i$ ob istem času, ko je nastavljen $dist[p] = i$, sledi, da $dist[p] = i = d(s,p)$. Ker $\pi[p] \in W_{i-1}$ in $\|p - \pi[p] \| \leq 1$ (vrstice 16, 17 in 19), obstaja najkrajša pot v $G(P)$ od $s$ do $p$, ki uporablja $(i-1)$-to povezavo poti od $s$ do $\pi[p]$, po indukciji pa ji sledi povezava $\pi[p]p$.
\end{proof}

\begin{figure}[htb]
\begin{center}
\ovalbox{~~~~
\begin{varwidth}{\linewidth}
\begin{codebox}
    \Procname{$\proc{UnweightedShortestPath}(P,r)$}
    \li zgradi Delaunayevo triangulacijo $DT(P)$
    \li \For$p\in P$ \Do
    	\li $\dist[p] \gets \infty$
    	\li $\pi[p] \gets \const{nil}$\End
    \li $\dist[r] \gets  0$
    \li $W_0 \gets \{ r\}$
    \li $i\gets1$
    \li \While $W_{i-1}\neq\emptyset$ \Do
    	\li zgradi pod. strukturo za poizvedbe \\
    	\> najbližjega soseda v $W_{i-1}$
    	\li $Q \gets W_{i-1}$ // generator točk kandidatk
        \li $W_{i}\gets\emptyset$
    	\li \While $Q\neq\emptyset$\Do
    		\li $q$ poljubna točka v $Q$
            \li odstrani $q$ iz $Q$
            \li \For $qp$ povezava v $DT(P)$ \Do
            	\li \If $\dist[p]=\infty$ \Then
					\li $w \gets$ najbližji sosed $p$ v $W_{i-1}$
					\li \If $|pw|\leq 1$ \Then
						\li $\dist[p]\gets i$
						\li $\pi[p]\gets w$
						\li dodaj $p$ v $Q$
						\li dodaj $p$ v $W_{i}$
						\End
                    \End
            	\End
            \End
        \li $i\gets i+1$
    \End
    \li \Return $\dist[\cdot]$ in $\pi[\cdot]$
    \\[-2mm]
\end{codebox}
\end{varwidth}
~~~~}\end{center}
\caption{Algoritem iz~\cite{CJ15} za izračun neuteženega drevesa najkrajših poti.}
\label{fig:SSSP}
\end{figure}

Da dobimo odgovor na vprašanje, ali je nek kandidat $p\in W_i$, uporabimo podatkovno strukturo, ki zna v zglednem času najti najbližjega soseda $q$ in preveriti, če je razdalja med njima manjša ali enaka 1.

Celotni algoritem je podan na sliki~\ref{fig:SSSP}.

\begin{lema}
\label{lema3}
Za izgradnjo drevesa SSSP potrebuje algoritem $UnweightedShortestPath(P,s)$ $\OO(n\log n)$ časa, kjer je $n$ velikost množice $P$.
\end{lema}

\begin{proof}
Glavne opazke, uporabljene v dokazu, so sledeče: vsaka točka v $P$ je dodana v $Q$ največ enkrat v vrstici 10 in enkrat v vrstici 20, izvajanje vrstic 13-21 za točko $q$ vzame $\OO(\deg_{DT(P)}(q)\log n)$, vsota stopenj v $DT(P)$ je $\OO(n)$, in v vrstici 9 porabimo $\OO(n\log n)$ časa skupaj za vse iteracije. Sledijo podrobnosti.

Delaunayeva triangulacija nad $n$ točkami se lahko izračuna v času $\OO(n\log n)$. Inicializacija v vrsticah 1-7 tako vzame $\OO(n\log n)$ časa. Dokazati moramo še, da zanka v vrsticah 8-22 vzame $\OO(n\log n)$ časa.

Izvajanje vrstic 9-11 vzame $\OO(|W_{i-1}|\log |W_{i-1}|) = \OO(|W_{i-1}|\log n)$ časa. Vsaka kasnejša poizvedba najbližjega soseda se izvede v času $\OO(\log n)$.

Vsaka izvedba vrstic 16-21 se izvede v času $\OO(\log n)$, kjer je najbolj zahteven korak poizvedba v vrstici 16. Vsaka izvedba vrstic 13-21 se izvede v času $\OO(\deg_{DT(P)}(q)\cdot\log n)$, ker se vrstice 16-21 izvedejo $\deg_{DT(P)}(q)$-krat.

Obravnavajmo eno izvedbo vrstic 9-22. Točke so dodane v $Q$ v vrsticah 10 in 20. V slednji je točka $p$ dodana v $Q$ natanko takrat, ko je dodana v $W_i$ (v vrstici 21). Iz tega sledi, da je $p$ dodana v $Q$ natanko takrat, ko pripada množici $W_{i-1}\cup W_i$. Poleg tega je vsaka točka iz $W_{i-1}\cup W_i$ dodana v $Q$ natanko enkrat: za vsako točko $p$, ki je dodana v $Q$, velja $dist[p]\leq i < \infty$, in da ne bo dodana nikoli več zaradi pogoja v vrstici 17.Iz tega sledi, da se zanka v vrsticah 12-22 izvede v času

\begin{equation}
\sum_{q\in W_{i-1}\cup W_i} \OO(\deg_{DT(P)}(q) \cdot \log n).
\end{equation}

Tako lahko omejimo porabljen čas v zanki v vrsticah 8-22 z

\begin{equation}
\label{bigo1}
\sum_i \OO \left( |W_i|\log n + \sum_{q\in W_{i-1}\cup W_i} (\deg_{DT(P)}(q) \cdot \log n) \right) .
\end{equation}

Z uporabo leme ~\ref{lema2}, ki pravi, da so množice $W_0,W_1,...$ parno disjunktne, ter relacijama $\sum_i |W_i| \leq n$ in 

\begin{equation}
\sum_{q \in P} \deg_{DT(P)}(q) = 2 \cdot |E(DT(P))| = \OO(n),
\end{equation}
časovna kompleksnost iz ~\ref{bigo1} postane $\OO(n\log n)$.
\end{proof}

\begin{izrek}
Naj bo $P$ množica $n$ točk v ravnini in naj bo $s$ točka v $P$. V času $\OO(n\log n)$ lahko iz neuteženega grafa $G(P)$ izračunamo drevo najkrajših poti s korenom $s$.
\end{izrek}

\begin{proof}
Zaradi leme ~\ref{lema3} porabi algoritem $UnweightedShortestPath(P,s)$ $\OO(n\log n)$ časa. Zaradi leme ~\ref{lema2} tabela $\pi[\cdot]$ pravilno opisuje drevo najkrajših poti v $G(P)$ s korenom $s$ in $dist[\cdot]$ pravilno opisuje razdalje najkrajših poti v $G(P)$.
\end{proof}
\afterpage{\FloatBarrier}
\section{Minimalna ločitev enotskih diskov}

Cabello in Giannopoulos~\cite{CG16} sta predstavila splošen algoritem za problem minimalne ločitve, ki se v najslabšem scenariju izvede v kubičnem času. Algoritem deluje za poljubne smiselne oblike, kot so recimo daljice ali elipse, in ne samo za enotske diske. Njegova splošnost je sicer prednost, a po drugi strani ne izkorišča nobenih lastnosti enotskih diskov.

V tem poglavju je opisan algoritem, ki problem minimalne ločitve z enotskimi diski reši v skoraj kvadratičnem času. Izboljšava temelji na treh sestavinah:
\begin{itemize}
\item reinterpretacija generičnega algoritma za diske. V izvirnem algoritmu moramo označiti točko znotraj vsake oblike. Pri diskih je izbira očitna - njihovo središče. S tem se opis in interpretacija algoritma poenostavita.
\item učinkovit algoritem za drevesa najkrajših poti nad grafom $G$. Primeren kandidat je algoritem, opisan v poglavju ~\ref{sssp-true}, ker izkorišča lastnosti grafa $G$.
\item kompaktna obravnava povezav v $G$ z uporabo sledečih orodij iz računske geometrije: območnih dreves, iskanja najbližjega soseda in dualnosti med točko in premico. 
\end{itemize}

\subsection{Splošni algoritem za ločevanje z diski}
\begin{figure}[htb]
\begin{center}
\ovalbox{~~~~
\begin{varwidth}{\linewidth}
\begin{codebox}
    \Procname{$\proc{GenericMinimumSeparation}(P,s,t)$}
    \li $\best \gets \infty$ // dolžina trenutno najboljše ločitve
    \li \For $r\in P$ \Do
    	\li $(\dist[~],\pi[~])\gets$ drevo najkrajših poti iz $r$ v $G(P)$
		\\ \> // izračunaj $N[~]$
    	\li $N[r]=0$
    	\li \For $p\in P\setminus \{r\}$ v nepadajočih vrednostih od $\dist[p]$ \Do
			\li $N[p]= N[\pi[p]]+ \CR(st,p\pi[p]) \pmod 2$
			\End
    	\li \For $pq\in E(G(P))$\Do
			\li \If $N[p]+N[q]+ \CR(pq,st) \pmod 2 =1$ \Then
				\li $\best \gets \min \{ \best, \dist[p]+\dist[q]+1\}$ 
				\End
			\End
		\End
    \li \Return $\best$
    \\[-2mm]
\end{codebox}
\end{varwidth}
~~~~}\end{center}
\caption{Prilagoditev splošnega algoritma za izračun minimalne ločitve za enotske diske.}
\label{fig:generic}
\end{figure}

Naj sprehod $W$ v grafu $G=\GG(P)$ definira ravninsko poligonsko krivuljo na očiten način: točke v $P$ povežemo med seboj z daljicami v danem zaporedju iz $W$. Notacijo bomo naredili ohlapnejšo in z $W$ označili kar samo krivuljo. Za poljubno vpeto drevo $T$ iz $G$ in poljubno povezavo $e\in E(G)\setminus E(T)$ naj bo $\cycle(T,e)$ edinstven cikel v $T + e$. Za poljubni sprehod v $G$ naj bo $\CR (st,W)$  število presečišč med daljico $st$ in krivuljo $W$ po modulu $2$. Naslednja lastnost je implicitna v~\cite{CG16}:
\begin{quote}
Naj bo $T$ vpeto drevo iz $G$. Množica enotskih diskov s središči v $P$ ločuje $s$ in $t$ natanko takrat, ko obstaja taka povezava $e\in E(G) \setminus E(T)$, da velja $\CR (st, \cycle(T,e))=1$.
\end{quote}

Posledica tega je, da najti minimalno ločitev pomeni isto kot najti najkrajši cikel v $G$, ki ima liho število presečišč z daljico $st$. Še več, iskanje lahko omejimo na konkretno družino ciklov. Naj bo $W^*$ poljuben optimalen cikel in naj bo $r^*$ poljubno vozlišče iz $W^*$. Fiksirajmo drevo najkrajših poti $T_{r^*}$ v $G$ s korenom $r^*$. Potem množica ciklov $\{ \cycle(T_{r^*},e)\mid e\in E(G)\setminus E(T_{r^*})\}$ vsebuje optimalno rešitev. To sledi iz tako imenovanega tri-potnega pogoja (ideja v ~\cite{CG16}, naj dodamo njen opis in/ali dokaz???). Ker   je $r^*$ neznan, preverimo kar vse korene (v primerih, kjer je optimalna rešitev velika, to pripelje do možnosti uporabe randomiziranega algoritma, kjer nekatere korene izberemo naključno). Velikost optimalne rešitve je dana z
\begin{align*}
\min \{& 1+d_G(r,p)+d_G(r,q) \mid \\
	   & r\in P,~ pq\in E(G)\setminus E(T_r),~
		\CR(st,\cycle(T_{r},pq))=1 \} .
\end{align*}
Vrednosti $\CR (st, \cycle(T_r,e))$ lahko za posamezno povezavo $e$ izračunamo v konstantnem amortiziranem času s preprostim knjigovodstvom.  Poglejmo fiksno drevo $T_r$. Za vsako točko $p\in P$ shranimo $N[p]$ kot pariteto števila presečišč poti v $T_r$ iz $r$ do $p$. Ko $p$ ni koren drevesa, lahko vrednost $N[p]$ izračunamo s pomočjo njegovega starša kot $N[p]=N[\pi[p]]+\CR(st,p\pi[p])$. V psevdokodi algoritma (vrstice 4-6) je  postopek enako opisan, čeprav lahko vrednosti $N[p]$ računamo tudi hkrati z računanjem drevesa najkrajših poti $T_r$.

Za vsako drevo najkrajših poti $T_r$ imamo potem 
\begin{align*}
	\forall pq\in E(G)\setminus E(T_r):&\\
	\CR (st, \cycle(T_r,pq)) =&~N[p]+N[q]+\CR(st,pq) \pmod 2\\
	\forall pq\in E(T_r):&\\
	0 =&~N[p]+N[q]+\CR(st,pq) \pmod 2
\end{align*}
ker se presečišča, ki smo jih šteli dvakrat, izničijo po modulu $2$. Podrobneje, pot v $T_r$ iz $r$ do najmanjšega skupnega prednika $p$ in $q$ je upoštevana dvakrat. Iz tega sledi, da je dovolj za vse povezave $pq$ v $G$ preveriti, če je vsota $N[p]+N[q]+\CR(st,pq)$ enaka $0$ po modulu $2$. Končni algoritem je podan na sliki ~\ref{fig:generic}.

Poglejmo si časovno kompleksnost algoritma. Za vsako točko $r\in P$ moramo izračunati drevo najkrajših poti v $G$. Kot smo omenili v poglavju ~\ref{sssp-true}, je to izvedljivo v času $\OO(n\log n)$. Za vsako povezavo $pq$ potem porabimo $\OO(1)$ časa. Za vsako točko $r$ to skupaj znese $O(n\log n+|E(G)|)$ časa, kar v najslabšem primeru pomeni kubično časovno zahtevnost. Boljši čas lahko dobimo s kompaktno obravnavo vseh povezav v $G$, kar je opisano v poglavju ~\ref{compact}.  

\subsubsection{Dualnost in dualni prostor}
Točka v ravnini ima dva parametra: koordinati $x$ in $y$. Nenavpična premica v ravnini ima prav tako dva parametra: smerni koeficient in odsek na ordinatni osi. To pomeni, da lahko naredimo bijektivno preslikavo množice točk v množico premic. Pri nekaterih se lahko nekatere lastnosti množice točk prenesejo v določene lastnosti množice premic. Lep primer so tri točke na premici, ki se preslikajo v tri premice, ki grejo skozi isto točko. Preslikavam, ki to omogočajo, pravimo dualne transformacije. Preprost primer dualne transformacije je sledeč. Naj bo $p \gets (p_x, p_y)$ točka v ravnini. Njen dvojnik $p^*$ je premica, definirana kot $p^* \gets (y \gets p_xx - p_y)$. Dvojnik premice $l: y \gets mx + b$ je taka točka $p$, da za njo velja $p^* \gets l$. Ali drugače rečeno, $l^* \gets (m, -b)$.  

Za dualno transformacijo pravimo, da objekte preslika iz primarnega v dualni prostor. Sliki objekta v dualnem prostoru pravimo $dvojnik$.  Določene lastnosti, ki držijo v primarnem, držijo tudi v  dualnem prostoru. Naj bo $p$ točka, $l$ pa premica v ravnini. Dualna transformacija $o \mapsto o^*$ ima naslednje lastnosti:
\begin{itemize}
\item ohranja vsebovanost: $p\in l$ natanko takrat, ko velja $l^*\in p^*$
\item ohranja vrstni red: $p$ leži nad $l$ natanko takrat,ko $l^*$ leži nad $p^*$.  
\end{itemize}

Dualno transformacijo se lahko uporabi tudi na drugih objektih, kot so recimo daljice. Smiselna izbira za $s^*$, kjer je $s$ daljica $\overline{pq}$, bi bila unija vseh dvojnikov točk na $s$. Rezultat je neskončna množica premic, ki se sekajo v eni točki. Grafično si to lahko predstavljamo kot unijo dveh območij $s^*$, ki sta omejeni s premicama $p^*$ in $q^*$ in se stikata v točki njunega presečišča (glej tudi sliko)~\cite{bkos-08}.

\subsection{Hitrejši algoritem}
\label{compact}
\begin{figure}
\centerline{\includegraphics[scale=1.2]{pics/dual_problem3.pdf}}
\caption{Množici $A$ (rdeči točki) ter $B$ (zelene točke) levo in desno od daljice $st$ (zgornja slika). Črtkani črti predstavljata premici, čigar koeficienta sta uporabljena za izračun koordinat dualne točke $\varphi (a_1)$, predstavljata pa tudi vidno polje točke $a_1$.} 
\label{dualp}
\end{figure}

\begin{figure}
\centerline{\includegraphics[scale=1.2]{pics/dual_problem4.pdf}}
\caption{Spodaj so prikazane točke iz slike ~\ref{dualp} v dualnem prostoru. Obarvano območje v sredini predstavlja prostor, v katerem se nahajajo vse take dualne točke $\varphi (b)$, za katere velja $b \in B(a_1)$. Obarvani območji levo in zgoraj predstavljata prostor dualnih točk $\varphi (b)$, za katere velja, da je presečišče premice $a_1b$ z osjo $y$ pod oziroma nad daljico $st$.} 
\label{dualp2}
\end{figure}

Uporabili bomo podatkovno strukturo v naslednji lemi. V osnovi gre za večnivojsko podatkovno strukturo, ki vsebuje dvodimenzionalno območno drevo $T$, slednje pa na vsakem vozlišču sekundarnega drevesa hrani podatkovno strukturo za iskanje najbližjega soseda. 

\begin{lema}
\label{lema-ds2}
Naj bo $B$ množica točk s pozitivnimi koordinatami $x$. $B$ lahko predprocesiramo v času $\OO(n\log^3n)$, tako da za vsako točko $a\in A$ z negativno koordinato $x$ lahko v času $\OO(\log^3n)$ določimo, če je množica $\{ b\in B \mid \text{$ab$ seka $\sigma$ and $|ab|\le 1$}\}$ prazna. Z isto podatkovno strukturo lahko obravnavamo poizvedbe za ugotavljanje, ali je množica $\{ b\in B \mid \text{$ab$ ne seka $\sigma$ and $|ab|\le 1$}\}$ prazna.
\end{lema}

\begin{proof}
Za potrebe dokaza uporabimo dualnost, opisano v prejšnjem poglavju, in območna drevesa.

Naj bo $\LL$ množica nenavpičnih premic, $\sigma^*$ pa množica točk dualnih nevertikalnim daljicam, ki sekajo daljico $\sigma = st$:

\[
		\sigma^* ~=~ \{ l^* \mid \ell\in \LL, \ell\cap \sigma\neq \emptyset\} 
\]

V dualnem prostoru je množica $\sigma^*$ $horizontal slab$

\[
		\sigma^* ~=~ \{ (m,-c)\in \RR^2\mid 0\le c\le s\},
\]
ker velja predpostavka $s=(0,0)$ and $t=(0,\tau)$, kjer $\tau\ge 0$.


Za vsako točko $b\in B$ naj bo $L^* _b$ množica točk, dualnih premicam, ki gredo skozi $b$ in sekajo $\sigma$:

\[
		L^*_b=\{ \ell^* \mid \ell\in \LL, b \in \ell, \text{ and } \sigma\cap \ell\not= \emptyset\}.
	\]

V dualnem prostoru je $L^* _b$ daljica, ki je popolnoma vsebovana v slabu $\sigma^*$ in ima krajišči $(\varphi_1(b),0)$ in $(\varphi_2(b),-\tau)$ na obeh njegovih mejah. $\varphi_1(b)$ predstavlja smerni koeficient premice, ki seka točki $(0,0)$ in $b$, $\varphi_2(b)$ pa smerni koeficient premice, ki seka točki $(0,\tau)$ in $b$.

Definirajmo točko preslikave $\varphi(b)=(\varphi_1(b),\varphi_2(b))$. Funkcija preslikave $\varphi$ torej preslika točke z nenegativnimi koordinatami $x$ v točke v ravnini.

Za vsak $b\in B$ velja neenakost $\varphi_1(b) \geq \varphi_2(b)$. Točke $B$ lahko razdelimo v tri skupine glede na predznaka koordinat točke preslikave $\varphi(b)$ in za vsako skupino je neenakost očitna:

\begin{align*}
    b_1 \in \{ (x,y) \mid (x,y) \in B, y < 0 \} \Rightarrow &~ \varphi_1(b),\varphi_2(b) < 0 \text{ and } \varphi_1(b) > \varphi_2(b) \\
b_2 \in \{ (x,y) \mid (x,y) \in B, 0 <= y < \tau \} \Rightarrow &~ \varphi_1(b) > 0, \text{ } \varphi_2(b) < 0 \\
    b_3 \in \{ (x,y) \mid (x,y) \in B, y >= \tau \} \Rightarrow &~ \varphi_1(b) > 0, \text{ } \varphi_2(b) >= 0 \text{ and }\\ 
    &~\varphi_1(b) > \varphi_2(b)
\end{align*}

Enakost velja le v primeru, ko sta premici, ki definirata obe koordinati, isti. Do slednjega pride pri točkah $b$ s koordinato $x$ enako $0$. 

Iz zgornje neenakosti sledi, da točke preslikave $\varphi(b)$ vedno ležijo na polravnini $x \geq y$ in da je smerni koeficient premice, na kateri leži daljica $L^*_b$, nepozitiven. Podobno lahko ugotovimo, da za vsak $a \in A$ točka $\varphi(a)$ leži na polravnini $\varphi_2(a) > \varphi_1(a)$ in da ima premica, na kateri leži daljica $L^*_a$, pozitiven smerni koeficient.

Naj bo $a \in A$ in $b \in B$. Daljica $ab$ seka daljico $\sigma$ natanko takrat, ko $L^*_a$ seka $L^*_b$, ker daljico $ab$ v dualnem prostoru predstavlja ravno presečišče $L^*_a$ in $L^*_b$. Iz tega sledi naslednja lastnost:

	\[
		ab \cap \sigma \neq \emptyset ~\Longleftrightarrow ~ 
		\varphi_1(a)\le \varphi_1(b)) \text{ in } \varphi_2(a)\ge \varphi_2(b)).
	\]	
	
Z drugimi besedami: za točko $a \in A$ množico točk $b \in B$, kjer $ab$ seka $\sigma$, sestavljajo točke $b$, pri katerih se $\varphi(b)$ nahaja v drugem kvadrantu koordinatnega sistema z izhodiščem $\varphi(a)$. (Bolj natančno, gre za točke $\varphi(b)$, ki se nahajajo v preseku drugega kvadranta omenjenega koordinatnega sistema s polravnino $x \geq y$. Glej sliko~\ref{dualp2}.)

Za shranjevanje množice točk $\varphi(B)$, kjer je vsaka točka $b \in B$ asociirana s točko preslikave $\varphi(b)$, lahko uporabimo dvodimenzionalno območno drevo. Na vsakem vozlišču $v$ sekundarnega drevesa shranimo podatkovno strukturo za poizvedbe najbližjega soseda nad kanonično množico $P(v)$, ki vsebuje točke shranjene pod $v$ v sekundarnem drevesu. 

Za vsako točko poizvedbe $a \in A$ lahko točke $b \in B$, kjer $ab$ seka $\sigma$, dobimo s poizvedbo na območnem drevesu, ki vrne točke $\varphi(B)$ v kvadrantu

\[
		\{(x,y)\mid  \varphi_1(a) \leq x \text{ and } \varphi_2(a) \geq y\}.
	\]

To pomeni, da množico $\{ b\in B \mid \text{$ab$ seka $\sigma$}\}$ dobimo kot unijo kanoničnih podmnožic $P(v_1),...,P(v_k)$ za $k = \OO(\log^2n)$ vozlišč v sekundarnem drevesu. Za vsako tako podmnožico $P(v_i)$ naredimo poizvedbo najbližjega soseda za točko $a$. Če za nek $v_i$ najdemo najbližjega soseda, ki je za razdaljo največ $1$ oddaljen od $a$, potem vemo, da je množica $\{ b\in B \mid \text{$ab$ seka $\sigma$ in $|ab|\le 1$}\}$ neprazna. V nasprotnem primeru je množica prazna.

Čas zgraditve dvodimenzionalnega območnega drevesa je $\OO(n\log n)$. Vsaka točka se pojavi v $\OO(\log^2n)$ kanoničnih podmnožicah $P(v)$. To pomeni, da $\sum_v |P(v)| = O( n\log^2 n)$, kjer vsota iterira skozi vsa vozlišča $v$ v sekundarnem drevesu. Ker za vsak $v$ zgradimo podatkovno strukturo za iskanje najbližjega soseda, kar vzame $O(|P(v)| \log |P(v)|)$ časa, je skupna časovna zahtevnost zgraditve podatkovne strukture $\OO(n\log^3n)$.

Za poizvedbe dvodimenzionalno območno drevo vzame $\OO(\log^2)$ časa, da  najde $\OO(\log^2)$ vozlišč $v_1,...,v_k$, tako da velja
\[
		\bigcup_{i=1}^k P(v_i) ~=~ \{ b\in B \mid \text{$ab$ seka $\sigma$}\},
\]
potem pa dodatno potrebujemo $\OO(\log n)$ časa za vsako vozlišče, da naredimo poizvedbo najbližjega soseda. Poizvedbe za $\{ b\in B \mid \text{$ab$ ne seka $\sigma$ and $|ab|\le 1$}\}$ naredimo z isto podatkovno strukturo nad točkami v drugih dveh kvadrantih (glej sliko~\ref{dualp2}).
\end{proof}

Podatkovna struktura za poizvedbe najbližjega soseda v lemi~\ref{lema-ds2} ima časovno zahtevnost zgraditve $\OO(n\log n)$ in časovno zahtevnost poizvedbe $(\log n)$. Če bi uporabili neko drugo podatkovno strukturo za poizvedbe najbližjega soseda s časom zgraditve $T_c(n)$ in časom poizvedbe $T_q(n)$, bi čas zgraditve v lemi~\ref{lema-ds2} postal $O(T_c(n\log^2 n))$, čas poizvedbe pa $O(T_q(n)\cdot \log^2 n)$.

Iz teoretičnega vidika bi bilo bolj učinkovito izračunati unijo
\[
	\bigcup_{b\in B} \{ (x,y)\in \RR^2\mid x<0,~ |(x,y)b|\le 1,~ (x,y) 
			\text{ seka } \sigma \}
\]
in tam narediti point location(???). Ker območja ne morejo imeti veliko presečišč z daljico $\sigma$, lahko dobimo dobre asimptotične meje. V praksi pa se izkaže, da je izboljšava rezultata zanemarljiva.
\bigbreak
Obravnavajmo zdaj fiksni koren $r$. Predpostavimo, da so drevo najkrajših poti $T_r$ ter tabele $\pi[~]$, $\dist[~]$ and $N[~]$ že izračunane. Točke združimo glede na njihovo razdaljo od $r$:
\[
	W_i ~=~ \{ p\in P \mid \dist[p]=i \},~~~ i=0,1,\dots
\]

Standardna lastnost dreves BFS, ki drži tudi tukaj,je da se razdalji od $r$ dveh sosednih vozlišč razlikujeta za največ $1$. To pomeni, da so sosedi točke $p\in P$ v $G$ vsebovani v $W_{\dist[p]-1}\cup W_{\dist[p]} \cup W_{\dist[p]+1}$. To lastnost bomo uporabili pri našem algoritmu.

Naredimo skupine $L_i^j$ in $R_i^j$ (kjer $L$ pomeni ``levo" in $R$ pomeni ``desno"), definirane kot
\begin{align*}
	L_i^j ~&=~ \{ p\in P \mid \dist[p]=i,~ p.x<0,~ N[p]=j \} ,
	~\text{kjer $j=0,1$ in $i=0,1,\dots$}\\
	R_i^j ~&=~ \{ p\in P \mid \dist[p]=i,~ p.x>0,~ N[p]=j \} ,
	~\text{kjer $j=0,1$ in $i=0,1,\dots$}
\end{align*}
Zanimajo nas povezave $pq$ v $G$, za katere velja $N[p]+N[q]+\CR(st,pq)=1 \pmod 2$. Z upoštevanjem simetrije je to ekvivalentno parom točk $(p, q)$ v enem od naslednjih dveh primerov:
\begin{itemize}
	\item za nek $i\in \NN$ in nek $j\in \{0,1\}$ imamo
			$p\in L_i^j\cup R_i^j$, 
			$q\in L_i^{1-j}\cup R_i^{1-j}\cup L_{i-1}^{1-j}\cup R_{i-1}^{1-j}$, 
			$|pq|\le 1$, in $pq$ ne seka $st$;
	\item za nek $i\in \NN$ in nek $j\in \{0,1\}$ imamo
			$p\in L_i^j\cup R_i^j$, 
			$q\in L_i^{j}\cup R_i^{j}\cup L_{i-1}^{j}\cup R_{i-1}^{j}$, 
			$|pq|\le 1$, in $pq$ seka $st$.
\end{itemize}
Oba primera se da učinkovito rešiti z enim od naslednjih primerov:
\begin{itemize}
\item Če želimo iskati kandidate $(p,q)\in L_i^j\times L_{i'}^{1-j}$ (ki ne morejo sekati $st$, ker ležijo na isti strani osi $y$), najprej preprocesiramo $L_{i'}^{1-j}$ za poizvedbe najbližjega soseda. Potem za za vsako točko $p$ v $L_i^j$ naredimo poizvedbo nad podatkovno strukturo, da najdemo njenega najbližjega soseda $q_p$ v $L_i^j$. Če za nek $p$ velja $|pq_p|\le 1$, smo našli povezavo $pq_p$ v $G$, za katero velja $\CR(\cycle(T_r,pq_p))=1$ in $\dist[p]+\dist[q_p]+1=i+i'+1$. Če za vsak $p$ velja $|pq_p|> 1$, potem $L_i^j\times L_{i'}^{1-j}$ ne vsebuje nobene povezave iz $G$. Če $m=|L_i^j|+|L_{i'}^{1-j}|$, je skupni čas izvajanja $\OO(m\log m)$.
\item Če želimo iskati kandidate $(p,q)\in L_i^j\times R_{i'}^{j}$, ki sekajo $st$, najprej preprocesiramo $R_{i'}^{j}$ v podatkovno strukturo, kot smo opisali v lemi~\ref{lema-ds2}. Nato za vsako točko $p\in L_i^j$ naredimo poizvedbo na podatkovni strukturi za take točke $q$, da $pq$ seka $st$. Če kot rezultat dobimo neprazno množico, potem obstaja $pq$ v $G$, za katero velja $p\in L_i^j$, $q\in R_{i'}^{j}$, $\CR(\cycle(T_r,pq))=1$ in $\dist[p]+\dist[q]+1=i+i'+1$. V nasprotnem primeru ne obstaja nobena povezava $pq\in L_i^j\times R_{i'}^{j}$, ki bi sekala $st$. Za $m=|L_i^j|+|R_{i'}^{j}|$ je skupni čas izvajanja  $O(m\log^3 m)$.
\item Če želimo iskati kandidate $(p,q)\in L_i^j\times R_{i'}^{1-j}$, ki ne sekajo $st$, najprej preprocesiramo $R_{i'}^{1-j}$ v podatkovno strukturo, kot smo opisali v lemi~\ref{lema-ds2}. Nato za vsako točko $p\in L_i^j$ naredimo poizvedbo na podatkovni strukturi za take točke $q$, da $pq$ ne seka $st$. Preostali potek je podoben kot v prejšnji točki. 
\end{itemize}
Sklenemo lahko, da vsakega od primerov lahko rešimo v času $\OO(m\log^3m)$ v najslabšem primeru, kjer je $m$ število točk udeleženih v primeru. Z iteracijo čez vse možne vrednosti $i$ je zdaj to preprosto pretvoriti v algoritem, ki porabi $\OO(n\log^3n)$ časa za vsak koren $r$. Za primer z enotskimi diski ta algoritem izboljša čas splošnega algoritma. 
\begin{izrek}
\label{lema4}
Problem minimalne ločitve $n$ enotskih krogov lahko rešimo v času $\OO(n^2\log^3n)$.
\end{izrek}

\begin{proof}
Naj bodo $P$ središča krogov in - tako kot prej - obravnavajmo graf $G=\GG(P)$. Za vsak $r\in P$ zgradimo drevo najkrajših poti in množice $W_i,L_i^0,L_i^1,R_i^0,L_i^1$ za vsak $i$ v času $O(n\log n)$. Nato imamo največ $n$ iteracij, kjer za vsako iteracijo $i$ porabimo $O(|W_i\cup W_{i-1}|\log^3 |W_i\cup W_{i-1}|)$ časa. Ker so množice $w_i$ disjunktne in če seštejemo čase vseh iteracij, je čas izvajanja za posamezen koren $r\in P$ enak $\OO(n\log^3n)$.

Pravilnost algoritma sledi iz dejstva, da računa isto kot splošni algoritem.
\end{proof}

\begin{figure}[htb]
\begin{center}
\ovalbox{~~~~
\begin{varwidth}{\linewidth}
\begin{codebox}
    \Procname{// Delo za koren $r\in P$}
   	\li $(\dist[~],\pi[~])\gets$ drevo najkrajših poti iz $r$ v $\GG(P)$
	\li Izračunaj nivoje $W_0,W_1,\dots$
	\li \For $i=0\dots n$ \Do
		\li Izračunaj $N[p]$ za vsak $p$ v $W_i$
		\li Izračunaj $L^0_i$, $L^1_i$, $R^0_i$, $R^1_i$
		\End
    \li $i=1$
    \li \While $2i< \best$ in $W_i\neq\emptyset$ \Do
		\\ \> // znotraj obeh strani osi $y$ 
		\li išči kandidate v \\
			\> ~~~$L^0_i\times L^1_{i-1}$, $L^1_i\times L^0_{i-1}$, 
				$R^0_i\times R^1_{i-1}$, \\
			\> ~~~$R^1_i\times R^0_{i-1}$,
				$L^0_i\times L^1_{i}$ in $R^0_i\times R^1_{i}$
		\\ \> // preko osi $y$ skozi $\sigma$
		\li išči kandidate, ki sekajo $\sigma$ v \\
			\> ~~~$L^0_i\times R^0_{i-1}$, $L^1_i\times R^1_{i-1}$, 
				$L^0_{i-1}\times R^0_{i}$, \\
			\> ~~~$L^1_{i-1}\times R^1_{i}$, $L^0_i\times R^0_{i}$ 
				in $L^1_i\times R^1_{i}$
		\\ \> // preko osi $y$ mimo $\sigma$			
		\li išči kandidate, ki ne sekajo $\sigma$ v \\
			\> ~~~$L^0_i\times R^1_{i-1}$, $L^1_i\times R^0_{i-1}$, 
				$L^1_{i-1}\times R^0_{i}$, \\ 
			\> ~~~$L^0_{i-1}\times R^1_{i}$, $L^0_i\times R^1_{i}$ 
				in $L^1_i\times R^0_{i}$		
		\li $i \gets i+1$
		\End
    \\[-2mm]
\end{codebox}
\end{varwidth}
~~~~}\end{center}
\caption{Work for each vertex in the new algorithm for minimum separation with unit disks.}
\label{fig:compact}
\end{figure}

\begin{figure}[htb]
\begin{center}
\scalebox{.92}{%
\ovalbox{~~~~
\begin{varwidth}{\linewidth}
\begin{codebox}
    \Procname{$\proc{SeparationUnitDisksCompact}(P,s,t)$}
    \li $\best \gets n+1$ // length of the best separation so far
    \li \For $r\in P$ \Do
    	\li $(\dist[~],\pi[~])\gets$ shortest path tree from $r$ in $\GG(P)$
		\\ \> // Compute the levels $W_i$
    	\li \For $i=0\dots n$ \Do
			\li $W_i\gets$ new empty list
			\End
    	\li \For $p\in P$ \Do
			\li add $p$ to $W_{\dist[p]}$
			\End		
		\\ \> // Compute $N[~]$ for the elements of $W_i$ and
		\\ \> // and construct $L_i^0,L_i^1,R_i^0,R_i^1$
    	\li $N[r]=0$
		\li \For $i=1\dots n$ \Do
			\li \For $p\in W_i$ \Do
				\li $N[p]= N[\pi[p]]+ \CR(st,p\pi[p]) \pmod 2$
				\li \If $p$ to the left of the $y$-axis \Then
					\li add $p$ to $L^{N[p]}_i$
					\End
				\li \If $p$ to the right of the $y$-axis \Then
					\li add $p$ to $R^{N[p]}_i$
					\End
				\End
			\End
    	
\end{codebox}
\end{varwidth}~~~~}}
\end{center}
%\caption{New algorithm for minimum separation with unit disks.}
%\label{fig:FULL}
\end{figure}

\begin{figure}[htb]
\begin{center}
\scalebox{.92}{%
\ovalbox{~~~~
\begin{varwidth}{\linewidth}
\begin{codebox}
		\li \Do $i=1$
    	\li \While $2i< \best$ and $W_i\neq \emptyset$ \Do
			\\ \>\> // length $2i$; within each side of the $y$-axis 
			\li search candidates in $L^0_i\times L^1_{i-1}$, $L^1_i\times L^0_{i-1}$,
			$R^0_i\times R^1_{i-1}$, $R^1_i\times R^0_{i-1}$
			\\ \>\> // length $2i$; across $y$-axis crosing $\sigma$
			\li search candidates crossing $\sigma$ in 
			\li $L^0_i\times R^0_{i-1}$, $L^1_i\times R^1_{i-1}$, $L^0_{i-1}\times R^0_{i}$, $L^1_{i-1}\times R^1_{i}$
			\\ \>\> // length $2i$; across $y$-axis not crosing $\sigma$			
			\li search candidates not crossing $\sigma$ in 
			\li $L^0_i\times R^1_{i-1}$ , $L^1_i\times R^0_{i-1}$, $L^0_{i-1}\times R^1_{i}$,$L^1_{i-1}\times R^0_{i}$
			\\ \>\> // length $2i+1$; within each side of the $y$-axis 
			\li search candidates in $L^0_i\times L^1_{i}$, $R^0_i\times R^1_{i}$
			\\ \>\> // length $2i+1$; across $y$-axis crosing $\sigma$
			\li search candidates crossing $\sigma$ in $L^0_i\times R^0_{i}$, $L^1_i\times R^1_{i}$ 
			\\ \>\> // length $2i+1$; across $y$-axis not crosing $\sigma$			
			\li search candidates not crossing $\sigma$ in $L^0_i\times R^1_{i}$, $L^1_i\times R^0_{i}$
			\li $i \gets i+1$
			\End
		\End
    \li \Return $\best$
    \\[-2mm]
\end{codebox}
\end{varwidth}~~~~}}
\end{center}
%\caption{New algorithm for minimum separation with unit disks.}
%\label{fig:FULL}
\end{figure}

Opis postopka za posamezen koren je shematično prikazan na sliki~\ref{fig:compact}. (Appendix: celotni algoritem???) Kot pri splošnem algoritmu spremenljivka $best$ hrani dolžino trenutno najkrajšega cikla. Na začetku lahko njeno vrednost nastavimo na $n+1$. Če algoritem konča z isto vrednostjo spremenljivke, potem za dane točke ne obstaja rešitev za problem minimalne ločitve. Ko obravnavamo določen koren $r$, nas zanimajo samo cikli s korenom $r$ in dolžino največ $best$. Ker ima poljuben cikel, ki gre skozi vozlišče v $W_i$, dolžino najmanj $2i$, lahko obravnavamo samo indekse $i$, za katere velja $2i < best$. Poleg tega lahko dodatno omejimo iskanje (kar sicer ni opisano v algoritmu, je pa uporabljeno pri implementaciji) tako, da najprej obravnavamo pare, ki tvorijo cikel z dolžino $2i$, na primer $L^0_i\times L^1_{i-1}$, in šele potem tiste z dolžino $2i+1$, na primer $L^0_i\times L^1_i$. Z uporabo takega zaporedja lahko končamo z iskanjem za koren $r$ takoj, ko najdemo povezavo v $while$ zanki, in preidemo na naslednji koren.

\chapter{Implementacija algoritma}
\label{ch3}


\section{SSSP drevo}

Algoritem za izgradnjo drevesa SSSP smo implementirali z mislijo na možnost njegove neposredne uporabe v algoritmu za ločevanje z diski. Posledično smo spustili nekaj funkcionalnosti dreves, ki jih kasneje v programu ne potrebujemo, po drugi strani pa dodali stvari, ki se ne tičejo drevesa, so pa potrebne kasneje. Tako na primer ne moremo dostopati do otrok vozlišč drevesa, po drugi strani pa pri dodajanju točk k drevesu te sproti tudi uvrstimo v eno izmed množic $L0$, $L1$, $R0$ in $R1$.

Za implementacijo smo uporabili razred $SSSPTree$ s štirimi zasebnimi atributi. Vsi so seznami točk tipa vector in vsaka hrani eno izmed omenjenih množic. Konstruktor kot vhodne parametre sprejme seznam točk $P$, točko izvora $r$ in daljico $st$ ter zgradi drevo. Metoda $getAllSets$ v seznamu vrne vse štiri atribute.

\subsection{Podatkovna struktura za točko}
\label{point-refs}
Algoritem zgradi drevo implicitno. To pomeni, da kot rezultat ne dobimo nobene nove strukture, ampak konstruktor vsako točko doda v enega od štirih seznamov in pri tem spremeni vrednost dveh njenih atributov:

\begin{itemize}
\item dist: hrani razdaljo do korena drevesa in je tipa $unsigned\texttt{\_}int$
\item parent: hrani svojega starša in je tipa deljen kazalec ($ang.$ shared pointer) - zakaj že shared???
\end{itemize}

Noben imed omenjenih atributov ni del razreda $Point\texttt{\_}2$ v CGAL, zato smo jih sami dodali. S pomočjo kazalca na starša se je tako od vsake točke drevesa možno sprehoditi do korena, nasprotno pa to ne velja.

\subsection{Podatkovna struktura za iskanje najbližjega soseda}
\label{why dt}

Kot smo omenili pri teoretičnem opisu algoritma v prejšnjem poglavju, pri gradnji množice $W_i$ točke kandidatke testiramo tako, da poiščemo njihove najbližje sosede v množici $W_{i-1}$. Nad slednjo zgradimo VD, točke kandidatke pa uporabimo za poizvedbe nad tako strukturo.

V praksi se pri uporabi knjižnice CGAL izkaže, da je za iskanje najbližjega soseda bolje uporabiti Delaunayevo triangulacijo. Do tega sklepa smo prišli z analizo implementacije obeh struktur:

\begin{quote}
\item Za iskanje najbližjega soseda z Voronoijevim diagramom uporabimo funkcijo $locate(Point$ $q)$, ki za rezultat vrne Voronoijevo središče, vozlišče, ali rob. V našem primeru vedno iščemo najbližje Voronoijevo središče, tako da v primeru, da je rezultat vozlišče ali rob, vrnemo enega od enako oddaljenih središč. Ker v CGAL-u objekt Voronoijevega diagrama interno hrani strukturo Delaunayeve triangulacije, v praksi potemtakem pravzaprav iščemo vozlišče v Delaunayevi triangulaciji. Funkcija $locate$ za izračun uporablja funktor za iskanje najbližjega Delaunayevega vozlišča, ki je definiran z drugo predlogo Voronoijevega diagrama. Imenuje se $Delaunay\U triangulation\U nearest\U site\U 2.$ Ta nato kliče funkcijo $nearest\U vertex(Point$ $q)$ v Delaunayevi triangulaciji.

Rezultat slednje je pravzaprav tisto, kar iščemo od samega začetka, zato se lahko znebimo Voronoijevega diagrama kot vmesnika in direktno uporabljamo Delaunayevo triangulacijo. Poleg poenostavitve kode in rešitve pa je pomemben faktor tudi optimizacija. Teoretična časovna kompleksnost iskanja najbližjega soseda je $\OO(\log n)$, povprečna časovna zahtevnost funkcije $nearest\U vertex(Point$ $q)$, ki za najdbo najbližjega vozlišča uporablja sprehod po povezavah triangulacije (ang. $line$ $walk$), pa je $\OO(\sqrt{n})$. Delaunayeva triangulacija v CGAL-u vsebuje tudi funkcijo $nearest\U vertex(Point$ $q,$ $Face\U handle$ $hint)$, kateri kot drugi argument podamo lice v Delaunayevi triangulaciji, pri katerem se iskanje začne. Če znamo podati dobro začetno lice, se časovna kompleksnost bistveno zmanjša (na $k$ korakov, kjer $k << n$). Problem pri uporabi Voronoijevega diagrama je potem tudi ta, da njena funkcija $locate$ ne podpira dodatnega argumenta za začetno lice. Tudi če bi tako funkcijo napisali sami, bi nastal problem pri tem, kako najti primerno lice oziroma kako dostopati do njega. Sama izbira lica v DT pa je očitna. Za točko $q$, ki jo dobimo iz vrste, in točko $p$, s katero tvorita povezavo v DT(P) (glej psevdokodo~\ref{fig:SSSP}), imamo za poizvedbo točki $p$ najbližjega vozlišča dve možnosti za dobrega kandidata za začetno lice. Če $q\in DT(W_{i-1})$, je dober kandidat katerokoli lice vozlišča $q$, sicer pa je to katerokoli lice starša točke $q$ v drevesu SSSP, ker je starš zagotovo vsebovan v $DT(W_{i-1})$. 

Za razliko od Voronoijevega diagrama, ki ima samo metodo za vstavljanje ene točke v strukturo, Delaunayeva triangulacija vsebuje tudi metodo, ki kot argument sprejme seznam točk. Te nato prostorsko sortira, preden jih eno po eno doda v strukturo~\cite{cgal:dd-ss-15a}. Prednost sortiranja je v tem, da so bili deli strukture, ki so obravnavani med vstavljanjem, z veliko verjetnostjo obravnavani tudi pri prejšnjem vstavljanju, in se zato z večjo verjetnostjo nahajajo v pomnilniku $cache$ kot v glavnem pomnilniku. Uporaba sortiranja ni optimalna izbira na vseh primerih vhodnih podatkov. Pri našem algoritmu se je izkazalo, da algoritem deluje počasneje, zato smo metodo prilagodili tako, da točk ne sortira. To niti ni toliko presenetljivo: vhodne točke, ki jih DT v $i$-ti iteraciji dobi iz seznama $W_{i-1}$, so deloma že smiselno sortirane. Z analizo si poglejmo, kako je zgrajen seznam $W_1$, ki vsebuje točke z razdaljo 1 od korena $r$. Za iskanje sosedov vozlišča $r$  uporabimo krožni iterator, ki se začne pri poljubnem sosedu in se nato s pomočjo lic premika do naslednjega. Sosedi si zato sledijo v smiselnem zaporedju, v katerem so tudi shranjeni v seznam $W_1$. Ko obiščemo vse sosede, moramo obiskati še vse sosede sosedov. Začnemo pri prvem obiskanem sosedu, in zopet s krožnim iteratorjem pogledamo vse sosede, in tako naprej do ostalih. V splošnem velja, da bodo sosedje soseda $i$ bolj blizu sosedom soseda $i+1$ kot soseda $i+2$, in s prvimi bolj verjetno tvorili povezavo v $DT(W_1)$ kot z drugimi. Drugače povedano: za novonastali trikotnik, ki je dodan v triangulacijo, je velika verjetnost, da meji na trikotnik, dodan v prejšnjem koraku. 
\end{quote}

Za učinkovito iskanje začetnega lica smo napisali razširitev razreda DT, imenovano $DTWithFaceMap$. Hrani zasebni slovar $pointsToFaceHandlers$, ki kot ključ hrani kazalec na objekt tipa $Point\U 2$, kot vrednost pa objekt tipa $DT\U Face\U handle$. Vsebuje tudi dodatno metodo za vstavljanje, ki kot argument sprejme seznam vozlišč tipa $DT_vertex_handle$. Iz vsakega objekta vozlišča dobi ven točko tipa $Point\U 2$, ki jo vstavi v DT z metodo $insert(Point\U 2 q)$, ki je že definirana  v razredu DT. Ta metoda vrne nov objekt vozlišča, ki je bilo dodano v strukturo. Objekt hrani informacijo o točki $q$ in licu $f$, na katerega vozlišče meji. Par $<q, f>$ nato shranimo v slovar $pointsToFaceHandlers$.

Pomembno dejstvo, ki ga je potrebno izpostaviti, je sledeče. Teoretično gledano je množica točk v DT($W_i$) podmnožica točk v DT(P). Ker CGAL razlikuje vozlišča in točke, triangulaciji za vozlišče v, ki ga obe vsebujeta, hranita vsak svoj lasten objekt. Oba objekta vozlišča hranita referenco na isto instanco točke.


Koda, ki se izvede za posamezno vozlišče $p$, je sledeča:

\begin{quote}
f = DT::insert((*p)-$>$point(), f)-$>$ face();\\
pointsToFaceHandlers[\&((*p)-$>$point())] = f;
\end{quote}



\begin{filecontents*}{DTWithFaceMap.h}
Face_handle getFaceFromPoint(const Point_2* p) { 
	return pointsToFaceHandlers[p]; 
}
	
ptrdiff_t insert(vector<DH_vertex_handle> points) {
	size_type n = this->number_of_vertices();
	Face_handle f;
	for (vector<DH_vertex_handle>::iterator p = points.begin(); p != points.end(); ++p) {
		f = DT::insert((*p)->point(), f)->face();
		pointsToFaceHandlers[&((*p)->point())] = f;
	}
	return this->number_of_vertices() - n;
}
\end{filecontents*}
\lstinputlisting[label=dtCode,caption=sample code,language=C++]{DTWithFaceMap.h}

Kot vidimo v kodi, metoda poleg najbližjega soseda vrne tudi spremenljivko logičnega tipa, ki nam pove, če je razdalja med točko poizvedbe in njenim najbližjim sosedom manjša ali enaka 1.

\subsection{Izgradnja drevesa} 

Za drevo SSSP smo napisali razred SSSPTree. Lahko je uporabljen samostojno ali za potrebe problema ločitve. Ponuja dva konstruktorja; prvi je SSSPTree(Iterator begin, Iterator end), drugi pa kot tretji argument sprejme še daljico $st$. Metoda $createTreeFromRoot(Point\U 2$ $r)$ zgradi drevo s podanim korenom. Če je bil uporabljen drugi konstruktur, se bodo v tej metodi poleg izgradnje drevesa izvedle še dodatne operacije, ki so opisane v naslednjem poglavju. 

Konstruktor najprej zgradi DT nad $P$. Nato za izvorno točko $r\in P$ s pomočjo metode $locate$ poišče vozlišče v DT, s katerim sovpada. Pri tem preventivno preveri, da je tip rezultata, ki ga vrne $locate$, resnično \\ 
$Delaunay\U Vertex\U Handle$, sicer $r\notin P$. Za vse točke v $P$ velja predpostavka, da sta vrednosti njihovih atributov $dist$ in $parent$ ponastavljeni. Velja torej $\forall p\in P:$ $p.dist = \infty$,  $p.parent = nullptr$.  

Za generatorja točk kandidatk uporabljamo objekt tipa $deque$, primeren za hranjenje elementov v vrsti. V teoretičnem opisu algoritma smo za $q\in Q$ rekli, da je poljubna točka v $Q$. V implementaciji je $q$ vedno prva točka v vrsti, kar je bolj optimalno, kot smo omenili v poglavju~\ref{why dt}. Za $W_i$ in $W_{i-1}$ v zanki hranimo seznam Delaunayevih vozlišč (objekte tipa $DT\U Vertex\U Handle$). Seznam $W_{i-1}$ vstavimo v strukturo\\ $DTWithFaceMap$. 

Za vsak $q\in Q$ poiščemo lice $f$, ki ga bomo uporabili kot namig pri iskanju najbližjega soseda. Če je razdalja $q$ enaka $i$, pomeni, da $q$ ni vsebovan v $W_{i-1}$ oziroma strukturi $DTWithFaceMap$. Ker pa je $q$ že v drevesu SSSP, lahko dostopamo do točke $qs$ (tipa $Point\U 2$), ki je njen starš.  Lice $f$ dobimo tako, da poiščemo vrednost objekta v mapi $pointsToFaceHandlers$, kot ključ pa uporabimo kazalec na starša $qs$. Če je razdalja $q$ manjša od $i$, kot ključ uporabimo kar kazalec na točko, ki jo interno hrani $q$.  

Povezave oziroma sosede $q$ najdemo s krožnim iteratorjem, ki ga vrne metoda $incident\U vertices(q)$ v DT. Ker ima v CGAL implementaciji DT poleg standardnih vozlišč še eno neskončno vozlišče, ki je sosedno vsem ostalim, moramo takega soseda ignorirati. Za ostale sosede $p$ najprej preverimo, če je njena točka bila že obiskana. Če ni, poiščemo njenega najbližjega soseda $w$ v $W_{i-1}$ z metodo $nearestVertex$, ki ji kot argument podamo $p$ in lice $f$. Če $|pw| <= 1$, usvarimo objekt tipa $shared\U ptr<Point\U 2>$, ki hrani kazalec na $w$. Ta objekt nato nastavimo kot starša točki v $p$. Točko tudi označimo kot obiskano in ji nastavimo razdaljo $i$, vozlišče $p$ pa vstavimo v seznam $W_i$. Na koncu iteracije $i$ seznam $W_{i-1}$ zamenjamo z $W_i$.



Zadnji dve točki nista omenjeni v psevdokodi, ker njuna uporabnost pride v poštev šele kasneje pri separaciji z diski. $updateNr$ vrne novo vrednost za atribut $nr$ točke $p$. Funkcija preveri, če daljica $pw$ seka $st$ in če jo, vrne $(w.getNr() + 1)$ $\%$ $2$, sicer vrne $w.getNr()$. $categorize$ točko $p$ na podlagi njenega atributa $nr$ in relativnega položaja glede na $st$ (ki je ali levo ali desno) doda v enega od štirih seznamov l0, l1, r0 ali r1.

\section{Drevo najbližjega soseda}

\begin{figure}
\centerline{\includegraphics[scale=0.5]{pics/nntree-png.png}}
\caption{Drevo najbližjega soseda, ki hrani 6 točk, prikazano v drevesni strukturi. Vrednosti vozlišč ponazarjajo število točk, shranjenih v objektu, ki omogoča poizvedbe najbližjega soseda, pod vozlišči pa so nanizane konkretne točke.}
\label{nntree}
\end{figure}

\begin{figure}
\centerline{\includegraphics[scale=0.5]{pics/nnarray-png.png}}
\caption{Drevo najbližjega soseda, ki hrani 6 točk, predstavljeno v obliki seznama. Za vsako celico so prikazani indeksi točk, ki jih hrani objekt v njej.}
\label{nnarray}
\end{figure}

Drevo najbližjega soseda, opisano v poglavju 3.3, bi lahko implementirali s kazalci ali seznamom. Odločili smo se slednjega. Seznam hrani kazalce ($shared{\_}ptr$) na objekte podatkovne strukture $DS(P(\nu))$ za poizvedbe najbližjega soseda. Velikost seznama, ki hrani $n$ točk, je enaka $2^{\lceil \log_2n \rceil+1}-1$. Nekatera vozlišča na najnižjem nivoju drevesa so lahko tudi prazna (torej brez objektov). Primer takega drevesa je prikazan na sliki ~\ref{nntree}. Otroka vozlišča, ki se v seznamu nahaja na mestu $i$, se nahajata na mestu $2i+1$ in $2i+2$. Podobno se starš vozlišča na mestu $i$ nahaja na mestu $\lfloor(i-1)/2\rfloor$.


Za podatkovno strukturo s poizvedbami najbližjega soseda smo sprva hoteli uporabiti VD, vendar smo se kasneje odločili za Kd drevo. Razlog za to je implementacija VD v knjižnici CGAL. Ker je prostorska kompleksnost VD $\OO(n)$, bi pričakovali, da poraba prostora raste linearno z večanjem VD. Izkaže se, da je rast počasnejša od linearne, kar pomeni, da na primer 100 VD objektov velikosti 10 porabi več prostora kot 10 objektov velikosti 100. Posledično poraba prostora ni enaka za vsak nivo drevesa, temveč z globino raste. Razlike se v celotnem algoritmu potem še potencirajo, ker zgradimo VD v (skoraj) vsakem vozlišču drevesa najbližjega soseda, vsako tako drevo pa v vsakem vozlišču sekundarnega drevesa v območnem drevesu. Ko smo testirali implementacijo Kd dreves v CGAL, smo ugotovili tudi, da je čas konstrukcije bistveno krajši kot pri VD. Primerjave med konstrukcijama obeh podatkovnih struktur (procesorski čas in poraba RAM-a) so prikazane v poglavju Rezultati.

\subsection{Kd drevo}

Kot osnovo smo za poizvedbe najbližjega soseda uporabili funkcijo $search$ v razredu $Kd{\_}tree$, ki kot argument sprejme $OutputIterator$, kamor se shranjujejo objekti, ki jih poizvedba vrne, in $FuzzyQueryItem$, ki je v dvodimenzionalnem primeru lahko krog ali pravokotnik in določa območje iskanja. Kot argument lahko sprejme vrednost $\epsilon$, ki določa stopnjo mehkosti (ang. fuzzyness) in se jo uporablja pri aproksimacijskih poizvedbah, ki pa jih v našem algoritmu nismo potrebovali. Časovna kompleksnost funkcije $search$ je enaka $\OO(\log n + k)$, kjer je $k$ število vrnjenih točk znotraj območja iskanja. Ker naš algoritem zahteva $\OO(\log n)$, smo razredu $Kd{\_}tree$ dodali podobno funkcijo, ki pa iskanje zaključi v istem trenutku, ko ugotovi, da se vsaj ena točka nahaja znotraj območja iskanja. Če na primer za neko notranje vozlišče Kd drevesa ugotovi, da vse točke v njegovem poddrevesu ustrezajo kriterijem iskanja, jih ne doda enega po enega v $OutputIterator$, temveč doda samo "dummy" točko in zaključi. Če najde samo eno točko (ko pride do lista Kd drevesa), potem tako točko tudi vrne. To si lahko privoščimo, ker nas v notranjih vozliščih drevesa najbližjega soseda ne zanimajo konkretne točke, ampak samo informacija, ali se vsaj ena točka nahaja v območju iskanja. Šele ko pridemo do lista NN drevesa, nas zanima konkretna točka. S tem, ko je vedno vrnjena ena točka, se časovna kompleksnost spremeni v $\OO(\log n)$.

\section{Implementacija optimizacijskega problema $\Phi_\sigma(A,B)$}

Za rešitev optimizacijskega problema, predstavljenega v poglavju ~\ref{opt2}, smo uporabili implementacijo območnih dreves v CGAL, za uporabo dualnosti pa napisali lasten razred (bolj natančno $struct$) $DualPoint$ za točke v dualnem prostoru.

\subsection{DualPoint - implementacija dualne točke}

Odločili smo se razlikovati po tipu med navadnimi točkami in točkami v dualnem prostoru, ki izhajajo iz premic v prvotnem prostoru. Razred $DualPoint$ hrani dva atributa. Prvi je točka v dualnem prostoru tipa $Point\texttt{\_}2$, poimenovan $point$. Drugi je kazalec na točko tipa $Point\texttt{\_}2$, poimenovan $originalPoint$. Če $point$ predstavlja točko $(\varphi_1(b), \varphi_2(b))$ (glej poglavje ~\ref{opt2}), potem $originalPoint$ predstavlja točko $b$. Konstruktor razreda kot argumenta sprejme točko $b$ in daljico $\sigma$ in s pomočjo funkcije $imagePoint$ izračuna točko preslikave.


\subsection{Območno drevo}
Za dvodimenzionalna območna drevesa smo uporabili implementacijo v knjižnici CGAL, ki jo predstavlja razred $Range\texttt{\_}tree\texttt{\_}2$. Vsako vozlišče hrani par $<kljuc, vrednost>$. Vrednost dodatno opisuje vozlišče in je lahko tudi prazna, ključ pa se uporablja pri izgradnji drevesa in poizvedbah. Oba argumenta sta predlogi, parametrizirani s konkretnima tipoma v razredu podana kot , kar pomeni, da moramo pri konstrukciji drevesa zanju podati konkretna tipa. 
Za ključ smo uporabili naš razred $Dual\texttt{\_}Point$, kot vrednost pa vsako vozlišče hrani svoje drevo NN (!).

Pri inicializaciji drevesu podamo seznam parov dualnih točk in praznega drevesa NN. Nato se iterativno sprehodimo po prvem nivoju drevesa (primarnem drevesu) - tako kot pri preiskovanju v širino - s funkcijo $traverse\texttt{\_}and\texttt{\_}populate\texttt{\_}with\texttt{\_}data$. Za vsako vozlišče pokličemo funkcijo $build\texttt{\_}NN\texttt{\_}Tree\texttt{\_}on\texttt{\_}layer2$, ki rekurzivno  od spodaj navzgor za vsako vozlišče v sekundarnem drevesu, na katerega kaže vozlišče v primarnem drevesu, vstavi v (v tistem trenutku prazno) njegovo drevo NN točke, ki jih hranita drevesi NN njegovih otrok. Pri listih je v drevo NN vstavljena točka, čigar dualna točka je uporabljena kot ključ vozlišča. Rekurzivni klic funkcije se torej kliče pred vstavljanjem točk v drevo NN. S pomočjo rekurzije je vsakemu notranjemu vozlišču v sekundarnem drevesu seznam točk v njegovem poddrevesu, ki ga potrebujemo za izgradnjo njegovega drevesa NN, implicitno podan preko dreves NN njegovih otrok. Če bi drevesa NN gradili od zgoraj navzdol v sekundarnem drevesu, bi morali za vsako vozlišče narediti sprehod po njegovem poddrevesu. V primarnem drevesu so vsa drevesa NN prazna.

\subsubsection{Poizvedbe v območnem drevesu}
Razredu $Range\texttt{\_}tree\texttt{\_}d$ smo za poizvedbe dodali funkcijo $window\texttt{\_}query\texttt{\_}impl\texttt{\_}modified$, ki  kot osnovo uporablja obstoječo funkcijo $window\texttt{\_}query\texttt{\_}impl$. Argumenti funkcije so $OutputIterator$, kamor se vstavljajo vrnjene točke, interval $I$, ki ga definirata dve dualni točki, tretji argument, ki ga v obstoječi funkciji ni, pa je točka $a$, ki jo uporabimo za poizvedbe najbližjega soseda v drevesih NN. Pri dvodimenzionalnih območnih drevesih je geometrijska predstavitev intervala pravokotnik; levo krajišče intervala ustreza spodnjemu levemu oglišču pravokotnika, desno krajišče pa zgornjemu desnemu oglišču. Interval je zaprt. 

Če za vozlišče $w$ v primarnem drevesu ugotovimo, da njegovo celotno poddrevo ustreza pogojem poizvedbe, nadaljujemo s preiskovanjem v njegovem sekundarnem drevesu. Če za vozlišče $v$ v sekundarnem vozlišču ugotovimo, da so vsa vozlišča v njegovem poddrevesu vsebovana v intervalu $I$, ne dodamo vso poddrevo v rezultat, kot je to storjeno v osnovni funkciji, temveč opravimo še poizvedbo najbližjega soseda točke $a$ v drevesu NN vozlišča $v$. Za vsako obiskano vozlišče $w$ v primarnem drevesu prav tako preverimo, če je vsebovano v intervalu $I$. Če je temu tako, točko, iz katere izhaja dualna točka, ki predstavlja ključ vozlišča $w$, dodamo v seznam vrnjenih točk. Enako velja za obiskana vozlišča v sekundarnem drevesu. [To pomeni vsi listi v sekundarnem drevesu. Naj listi sploh hranijo kd drevo velikosti 1?] 


\lstinputlisting[language=C++, firstline=1, lastline=37]{KdTreeQuery.h}

\lstinputlisting[language=C++, firstline=1, lastline=33]{NNquery.h}

\section{Minimalno ločevanje}

\begin{figure}
\centerline{\includegraphics[scale=0.7]{pics/primer1.png}}
\caption{Dodaj primer množic L0, L1, R0, R1. }
\label{primer-sep}
\end{figure}


Za rešitev optimizacijskega problema $\Psi_\sigma(r,P)$ (glej lemo ~\ref{lema6}) smo napisali dve funkciji, ki rešita optimizacijska problema $\Phi(A,B)$ in $\Phi_\sigma(A,B)$.

\subsection{opt1}
Funkcija $findMinPair(S_i, S_{i+1}, currentMinWeight)$ reši optimizacijska problema $\Phi(L_0, L_1)$ in $\Phi(R_0, R_1)$. Parameter $currentMinWeight$ hrani trojko $(a, b, w_a + w_b)$, kjer točki $a$ in $b$ s povezavo $ab$ tvorita trenutno najbolj optimalno pot.

Nad točkami $p\in S_{i+1}$ zgradimo drevo $NN(S_{i+1})$. Za vsako točko $q\in S_i$ naredimo poizvedbo najbližjega soseda v drevesu, če je razdalja $q$ do korena drevesa $SSSP$ manjša od dolžine trenutno najbolj optimalne poti. Za točko $b$, ki jo vrne poizvedba, preverimo, če je vsota uteži $w_q + w_b$ manjša od $w_a+w_b$. Če je temu tako, posodobimo $currentMinWeight$ z $(q, b, w_q + w_b)$.

\subsection{opt2}
Funkcija $findminpairRi (L_i, L_j, R_i, currentMinWeight, st)$. Šest instanc problema $\Phi_\sigma(A,B)$ v $\Psi_\sigma(r,P)$ ne rešujemo neodvisno, ker bi sicer morali šestkrat konstruirati območno drevo. Probleme z isto podmnožico $R_i$ združimo pod skupni problem, ki ga s funkcijo rešimo na sledeč način.

Zgradimo območno drevo s točkami $p\in R_i$. Za vsako točko $p_i\in L_i$ naredimo poizvedbo v območnem drevesu, pri čemer za območje iskanja podamo  drugi kvadrant koordinatnega sistema, ki ima za izhodišče točko $\varphi (p_i)$. Levo krajišče tako predstavlja točka $(\varphi_1 (p_i), -\infty)$, desno pa točka $(\infty, \varphi_2 (p_i))$. Parameter $st$ predstavlja daljico $\sigma$, s katero lahko izračunamo dualne točke. Parameter $currentMinWeight$ hrani trojko $(a, b, w_a + w_b)$, kjer točki $a$ in $b$ s povezavo $ab$ tvorita trenutno najbolj optimalno pot, izračunano z do zdaj rešenimi optimizacijskimi problemi $\Phi$ in $\Phi_\sigma$. Za vse točke $q_k$, ki jih vrne poizvedba, preverimo, če je vsota uteži $w_{p_i} + w_{q_k}$ manjša od $w_a+w_b$. Če je temu tako, posodobimo $currentMinWeight$ z $(p_i, q_k, w_{p_i} + w_{q_k})$. 

Funkcijo smo optimizirali tako, da smo zmanjšali število poizvedb. Poizvedb ne delamo s točkami, pri katerih je razdalja do korena drevesa SSSP večja od vsote razdalj točk $a$ in $b$, ki tvorita trenutno optimalno zaprto pot. S poizvedbami nad drugim kvadrantom rešimo problem $\Phi_\sigma(L_i,R_i)$.

Funkcija potem nadaljuje s poizvedbami za vsako točko $p_j\in L_j$. Za vsak $p_j$ opravimo dve poizvedbi. Pri eni za območje iskanja podamo prvi kvadrant, pri drugi pa tretji kvadrant koordinatnega sistema, ki ima za izhodišče točko $\varphi (p_j)$. Za vse točke $q_l$, ki jih vrneta poizvedbi, nato zopet preverimo vsoto uteži $w_{p_j} + w_{q_l}$ in po potrebi posodobimo $currentMinWeight$.

S poizvedbami nad prvim kvadrantom rešimo problem $\Phi_{\sigma_+}(L_j,R_i)$, s poizvedbami nad tretjim kvadrantom pa problem $\Phi_{\sigma_-}(L_j,R_i)$. Glej tudi sliko ~\ref{dualp}. Območje iskanja v teoretičnem pogledu ne določajo samo kvadranti, temveč tudi polravnina $x \geq y$. Ampak presek obeh območij ni pravotnik, za območje iskanja v območnem drevesu pa ne moremo vzeti poljubnega poligona. Omejitev območja iskanja tudi ne prinaša nobenih prednosti. Vse točke $b\in B$ se nahajajo v omenjeni polravnini, točke na drugi strani polravnine, ki se nahajajo v prvem, drugem ali tretjem kvadrantu, pa pripadajo množici točk na levi strani osi $y$, ki niso shranjene v območnem drevesu.

Funkcija se izvede dvakrat, kar pomeni, da tudi območno drevo zgradimo dvakrat; enkrat za $R_0$ in enkrat za $R_1$. Za točke v $L_0$ in $L_1$ naredimo tri poizvedbe; po enkrat v prvem, drugem in tretjem kvadrantu.

\subsection{Kreiranje cikla}
Ko dobimo par točk $a, b\in P$, ki določata minimalno zaprto pot, ki ločuje točki $s$ in $t$, v seznam shranimo vse točke, ki tvorijo cikel. S pomočjo funkcije $getParent()$ lahko za vsako točko $p$ v drevesu $SSSP(r, P)$ dobimo njegovega starša in s tem pot $T_r[p]$ v obratnem vrstnem redu (z začetkom pri točki $p$ in koncem pri točki $r$), ki jo označimo kot $T_r^{-1}[p]$. Pot $T_r[p]$ brez točke $r$ označimo z $T_{r-1}[p]$. Cikel lahko potem dobimo z združitvijo dveh poti $T_r^{-1}[a] + T_{r-1}[b]$, s čimer dobimo pot $(a,...,r,...b)$. Vrnjen seznam predstavlja cikel, v katerem je začetna točka shranjena samo enkrat. Za dolžino najbolj optimalne poti se do konca izvajanja programa hrani vsota dolžin točk $a$ in $b$. Dolžina, ki jo program vrne kot rezultat, je povečana za 1.

\section{Obravnava posebnih vhodnih primerov}
Pri algoritmu ločevanja z diski smo večkrat omenili, da je za daljico $\sigma$ privzeto, da je vertikalna. Če želimo uporabiti algoritem na primeru, kjer daljica ni vertikalna, je potrebno vse vhodne točke predhodno rotirati 

točke, ki ležijo na y osi, grejo k b (preveri tip neskončne vrednosti v dualpoint)


\chapter{Eksperimenti in rezultati}
\label{ch3}
Eksperimente smo izvedli na prenosnem računalniku z operacijskim sistemom Windows 10, procesorjem CPU i5-5200U z 2.20 Ghz in 8GB spomina. Za vizualizacijo domen, vhodnih podatkov in rezultatov smo napisali skripte v Pythonu in pri tem uporabili knjižnico $Matplotlib$.
\section{Generator vhodnih podatkov}
\begin{figure}
\centerline{\includegraphics[scale=0.75, page=1]{pics/data_generation.pdf}}
\caption{. }
\label{generation1}
\end{figure}

\begin{figure}
\centerline{\includegraphics[scale=0.75, page=2]{pics/data_generation.pdf}}
\caption{. }
\label{generation2}
\end{figure}

Točke smo generirali naključno znotraj sledečih poligonskih domen: pravokotnik brez lukenj, pravototnik z manjšo luknjo, pravokotnik z večjo luknjo, pravokotnik s štirimi manjšimi luknjami in pravokotnik s štirimi večjimi luknjami. Natančne dimenzije domen so prikazane na slikah ~\ref{generation1} in~\ref{generation2}. Konkretno smo uporabili domene, kjer je imel zunanji pravokotnik dimenzije $4\times 1$, $8\times 2$,\ldots, $128\times 32$. Velikost vhodnih podatkov je bila 1K, 2K, 5K, 10K, 20K in 50K točk. Podatke smo generirali enkrat in nato zapisali v tekstovno datoteko. Pri testiranju problema minimalne ločitve smo točko $s$ postavili na sredino luknje, $t$ pa vertikalno nad $s$ in zunanjim pravokotnikom. Prvi dve točki v tekstovni datoteki, ki hrani vhodne podatke, sta vedno obravnavani kot točki $s$ in $t$. Domen s premajhnimi luknjami nismo uporabili za problem minimalne ločitve, ker je višina lukenj manjša od $1$ in bi drevo najkrajših poti vsebovalo povezave med točkama na nasprotnih straneh luknje. S tem bi se vloga luknje izgubila in bi kot rešitev dobili trivialni cikel. 

Pri večjih domenah in manjših vhodnih podatkih je bil izziv zapolniti prostor, ki je pogoj za obstoj rešitve minimalnega problema, saj so točke bolj razpršene. Za vhodne podatke sicer nismo zahtevali pogoja, da je njihov graf $G$ povezan, smo pa želeli, da je velikost največje komponente $G$ dovolj podobna velikosti celotnega grafa $G$. S tem smo povečali možnost obstoja rešitve in dosegli, da smo dejansko testirali želeno število vhodnih podatkov. Nekatere kombinacije (na primer $1000$ točk na domeni z zunanjim pravokotnikom $128\times 32$) smo zato izpustili, pri drugih pa smo problem rešili tako, da smo za začetnih $m$ generiranih točk preverili, da imajo vsaj $k$ sosedov (točk, od katerih so oddaljene za največ $1$) med trenutnimi vhodnimi podatki. Če pogoj ni bil izpolnjen, smo generirano točko zavrgli. S tem smo generator na začetku spodbudili k zapolnjevanju prostora domene. Vrednosti $m$ in $k$ smo nastavili za vsako kombinacijo posebej s pomočjo kalibracije. $k$ se je gibal med $3$ in $5$ (manjši $k$ pomeni hitrejše zapolnjevanje prostora, zato smo ga uporabili pri večjih domenah), $m$ pa okrog številke $500$.





\begin{table}
\begin{center}
\begin{tabular}{l|l|l|l|l|l|l}
\hline
number of točk & 50k & 100k & 250k & 500k & 750k & 1mio \\ \hline \hline
CPU(VD) [s] & 0.0859 & 0.196 & 0.562 & 1.2667 & 2.0495 & 2.9304 \\ \hline
CPU(kd drevo) [s] & 0.0025 & 0.0047 & 0.0126 & 0.025 & 0.0375 & 0.0497
\end{tabular}
\end{center}
\label{cpu_compare}
\caption{Časi konstrukcij Voronoijevega diagrama in kd drevesa v sekundah. Vsaka konstrukcija se je izvedla desetkrat, na podlagi tega pa se je izračunal povprečni čas izvedbe.}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}{l|l|l|l|l|l|l}
number of točk & 50k & 100k & 250k & 500k & 750k & 1mio \\ \hline \hline
RAM(VD) [mb] & 7.2 & 14.4 & 34.3 & 68.9 & 103.6 & 137.9 \\ \hline
RAM(kd drevo) [mb] & 1.9 & 3.8 & 9.5 & 19 & 28.5 & 38.1
\end{tabular}
\end{center}
\label{ram_compare}
\caption{Velikost prostora v megabajtih, ki ga zasede en objekt Voronoijevega diagrama ali kd drevesa.}
\end{table}





\section{Drevo najkrajših poti}
Implementacijo algoritma SSSP smo primerjali z dvema očitnima alternativnima algoritmoma za drevesa najkrajših poti. Pri prvi eksplicitno zgradimo graf $G=\GG(P)$ tako, da za vse možne pare $p, q\in P$ dodamo povezavo $pq$ v strukturo grafa, če je razdalja med $p$ in $q$ največ 1. Za dan koren $r$ nato za izgradnjo drevesa uporabimo splošno iskanje v širino (BFS). Predprocesiranje (izgradnja grafa $\GG(P)$) ima kvadratno časovno zahtevnost, čas izgradnje drevesa pa je odvisen od gostote grafa.

Kot drugo alternativo uporabimo mrežo enotskih razdalj (glej poglavje~\ref{grid-chapter}). Dve točki $(x,y)$ in $(x',y')$ se nahajata v isti celici mreže natanko takrat, ko velja $(\lfloor x\rfloor ,\lfloor y\rfloor)=(\lfloor x'\rfloor ,\lfloor y'\rfloor)$. Vse točke v celici $c$ shranimo v seznam $\ell(c)$. Vse neprazne sezname $\ell(c)$ shranimo v slovar, v katerem je kot ključ uporabljeno spodnje levo oglišče celice. S tako strukturo nato izvedemo nekakšno preiskovanje v širino. Seznam $\ell(c)$ celice $c$ hrani točke, ki še niso bile obiskane z drevesom najkrajših poti. Ko procesiramo točko $p$ v celici $c$, moramo kot kandidate obravnavati vse ostale točke v $\ell(c)$ in točke v seznamih osmih sosednih celic. Vsaka točka, ki je sosedna $p$, je nato odstranjena iz seznama svoje celice. Predprocesiranje (izgradnja slovarja) ima linearno časovno zahtevnost, čas izgradnje drevesa pa je odvisen od porazdelitve točk. Enostavno se da najti primere, kjer bi bil ta čas kvadratičen. Za vsako najkrajše drevo slovar zgradimo od začetka. Ker je čas, ki ga porabimo za to, zanemarljiv, čas predprocesiranja za mrežo ni prikazan med rezultati.  

\begin{table}
\begin{center}
\begin{tabular}{l*{3}{r}}
Pravokotnik brez lukenj & \multicolumn{3}{c}{20K točk}\\						
dimenzije pravokotnika	&	$4\times 1$	&	$8\times 2$	&	$16\times 4$ \\
\hline
predprocesiranje SSSP	&	0.025	&	0.027	&	0.025		\\
povprečje za koren s SSSP	&	0.131	&	0.130	&	0.127		\\
predprocesiranje BFS 	&	25.057	&	20.433	&	17.773		\\
povprečje za koren z BFS	&	3.406	&	1.359	&	0.404		\\
mreža	&	1.605	&	1.647	&	0.695	\vspace{.2cm}	\\

&	$32\times 8$	&	$64\times 16$	&	$128\times 32$	\\
\hline
predprocesiranje SSSP &	0.025	&	0.025	&	0.026 \\
povprečje za koren s SSSP &	0.126	&	0.129	&	0.136 \\
predprocesiranje BFS &	17.734	&	17.347	&	17.179 \\
povprečje za koren z BFS &	0.088	&	0.025	&	0.009 \\
mreža &	0.227	&	0.089	&	0.053 \vspace{.2cm} \\
\hline
  & \multicolumn{3}{c}{50K točk}  \\						
&	$4\times 1$	&	$8\times 2$	&	$16\times 4$ \\
\hline
predprocesiranje SSSP	&	0.091	&	0.091	&	0.070		\\
povprečje za koren s SSSP	&	0.592	&	0.562	&	0.375		\\
predprocesiranje BFS	&	$>$3min	&	159.812	&	144.965		\\
povprečje za koren z BFS	& omejitev RAM-a & 9.378	&	2.789		\\
mreža				&	11.567	&	13.660	&	4.592	\\

&	$32\times 8$	&	$64\times 16$	&	$128\times 32$	\\
\hline
predprocesiranje SSSP &	0.071	&	0.070	&	0.069 \\
povprečje za koren s SSSP &	0.377	&	0.372	&	0.366 \\
predprocesiranje BFS &	140.404	&	131.854	&	132.475 \\
povprečje za koren z BFS &	0.584	&	0.144	&	0.044 \\
mreža &	1.346	&	0.432	&	0.187
\end{tabular}
\caption{Times for shortest paths in Pravokotniks without luknje.}
\label{table1}
\end{center}
\end{table}



\begin{table}
\begin{center}
\begin{tabular}{l*{3}{r}}
Pravokotnik 1 small hole & \multicolumn{3}{c}{10K točk}\\						
dimenzije pravokotnika	&	$4\times 1$	&	$8\times 2$	&	$16\times 4$		\\
\hline
predprocesiranje SSSP	&	0.021	&	0.012	&	0.012		\\
povprečje za koren s SSSP	&	0.104	&	0.059	&	0.060		\\
predprocesiranje BFS	&	8.500	&	4.300	&	4.100		\\
povprečje za koren z BFS	&	1.183	&	0.318	&	0.091		\\
mreža	&	0.486	&	0.513	&	0.168  \vspace{.2cm}	\\
&	$32\times 8$	&	$64\times 16$	&	$128\times 32$ \\
predprocesiranje SSSP &	0.012	&	0.012	&	0.012 \\
povprečje za koren s SSSP &	0.061	&	0.064	&	0.070 \\
predprocesiranje BFS &	4.100	&	4.000	&	4.000 \\
povprečje za koren z BFS &	0.026	&	0.008	&	0.003 \\
mreža &	0.072	&	0.035	&	0.026\vspace{.2cm} \\
\hline
  & \multicolumn{3}{c}{20K točk}\\
  &	$4\times 1$	&	$8\times 2$	&	$16\times 4$		\\  			
\hline
predprocesiranje SSSP	&	0.027	&	0.026	&	0.025	\\
povprečje za koren s SSSP	&	0.142	&	0.137	&	0.136	\\
predprocesiranje BFS	&	24.813	&	19.817	&	18.396	\\
povprečje za koren z BFS	&	3.253	&	1.328	&	0.467	\\
mreža				&	2.181	&	2.627	&	0.668	\\
&	$32\times 8$	&	$64\times 16$	&	$128\times 32$ \\
predprocesiranje SSSP &	0.025	&	0.025	&	0.025	\\
povprečje za koren s SSSP &	0.136	&	0.138	&	0.145	\\
predprocesiranje BFS &	17.976	&	17.542	&	17.313	\\
povprečje za koren z BFS &	0.108	&	0.031	&	0.011	\\
mreža &	0.262	&	0.104	&	0.060 
\end{tabular}
\caption{Times for shortest paths in Pravokotniks with a small hole.}
\label{table2}
\end{center}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}{l*{3}{r}}
Pravokotnik 4 small luknje & \multicolumn{3}{c}{10K točk} \\
dimenzije pravokotnika	&	$32\times 8$	&	$64\times 16$	&	$128\times 32$	\\						
\hline
SSSP preprocessing	&	0.021	&	0.018	&	0.018	\\
povprečje za koren s SSSP	&	0.056	&	0.058	&	0.064	\\
predprocesiranje BFS	&	6.291	&	6.102	&	6.364	\\
povprečje za koren z BFS	&	0.033	&	0.010	&	0.004	\\
mreža				&	0.064	&	0.031	&	0.023	\\
\hline
& \multicolumn{3}{c}{20K točk} \\
\hline
predprocesiranje SSSP &  0.027	&	0.026	&	0.026 \\
povprečje za koren s SSSP &	0.125	&	0.126	&	0.131 \\
predprocesiranje BFS &	18.325	&	17.887	&	17.256	\\
povprečje za koren z BFS & 0.102	&	0.031	&	0.010 \\
mreža &	0.230	&	0.096	&	0.055 
\end{tabular}
\caption{Časi za najkrajše poti v pravokotnikih s 4 manjšimi luknjami.}
\label{table4}
\end{center}
\end{table}


\begin{table}
\begin{center}
\begin{tabular}{l*{3}{r}}
Pravokotnik 4 večje luknje & \multicolumn{3}{c}{5K točk} \\
dimenzije pravokotnika	&	$32\times 8$	&	$64\times 16$	&	$128\times 32$ \\						
\hline
predprocesiranje SSSP	&	0.007	&	0.009	&	0.009	\\
povprečje za koren s SSSP	&	0.027	&	0.028	&	0.026	\\
predprocesiranje BFS	&	1.420	&	1.420	&	1.390	\\
povprečje za koren z BFS	&	0.007	&	0.003	&	0.002	\\
mreža				&	0.019	&	0.013	&	0.010	\\
\hline
& \multicolumn{3}{c}{10K točk} \\
\hline
predprocesiranje SSSP &	0.012	&	0.018	&	0.019	\\
povprečje za koren s SSSP &	0.057	&	0.054	&	0.053	\\
predprocesiranje BFS &	5.740	&	5.660	&	5.720	\\
povprečje za koren z BFS &	0.028	&	0.013	&	0.007	\\
mreža &	0.060	&	0.038	&	0.027 
\end{tabular}
\caption{Časi za minimalno ločevanje s 4 večjimi luknjami.}
\label{table5}
\end{center}
\end{table}

\section{Minimalno ločevanje}
\begin{table}[h!]
\begin{center}
\begin{tabular}{l*{4}{r}}
Pravokotnik 1 manjša luknja & \multicolumn{4}{c}{2K točk}\\
dimenzije pravokotnika	&	$8\times 2$	&	$16\times 4$	&	$32\times 8$ & $64\times 16$ \\	
\hline
nov algoritem za ločevanje	&	65	&	64	&	53	&	38  \\
generičen algoritem			&	215	&	87	&	43	&	29
\end{tabular}
\caption{Časi za minimalno ločevanje z eno manjšo luknjo.}
\label{table6}
\end{center}
\end{table}

\begin{table}[h!]
\begin{center}
\begin{tabular}{l*{3}{r}}
Pravokotnik 4 luknje & \multicolumn{3}{c}{2K točk, manjše luknje} \\
dimenzije pravokotnika	&	$32\times 8$ &	$64\times 16$ & $128\times 32$ \\	
\hline
nov algoritem za ločevanje	&	29	&	35	&	35	\\
generičen algoritem			&	80	&	40	&	30	\\
\hline
& \multicolumn{3}{c}{5K točk, večje luknje} \\
\hline
nov algoritem za ločevanje &	413 & 451 & 388  \\
generičen algoritem &	416 & 266 & 206
\end{tabular}
\caption{Časi za minimalno ločevanje s 4 luknjami.}
\label{table7}
\end{center}
\end{table}

\begin{figure}
\centerline{\includegraphics[scale=0.3]{pics/separation-64-1-1000-narrow-2.png}}
\caption{. }
\label{sep-64-1-1000-narrow}
\end{figure}

\begin{figure}
\centerline{\includegraphics[scale=0.3]{pics/32-1-5000-stuffed.png}}
\caption{. }
\label{sep-stuffed}
\end{figure}


\subsection{Analiza}
\begin{table}[h!]
\begin{center}
\begin{tabular}{l*{1}{c}}
 & \multicolumn{1}{c}{Časovna porast za 11K točk (1K zgoščenih)} \\
\hline
predprocesiranje SSSP &	9.7\%		\\
povprečje za koren s SSSP &	13.6\%	\\
predprocesiranje BFS & 21.9\%	\\
povprečje za koren z BFS &	56.5\% \\
mreža &	25\%
\end{tabular}
\caption{Časi za minimalno ločevanje s 4 luknjami.}
\label{table-increase}
\end{center}
\end{table}

Za razliko od SSSP algoritma BFS in mreža nimata nikakršne garancije za najslabši primer. Za oba lahko zgradimo takšne vhodne množice $P$, pri katerih bo njuna izvedba zelo počasna. Kot primer smo testirali $P$ s 10000 točkami v pravokotniku, ki ima dimenzije $32\times 8$ in majhno luknjo. Med krajiščema daljice $st$ smo nato v majhnem zgoščenem prostoru dodali še dodatnih 1000 točk. Čas izvajanja je glede na prvotno instanco najmanj narastel za SSSP, največ pa za BFS (glej tabelo~\ref{table-increase}).
\chapter{Sklepne ugotovitve}
\label{ch4}


\bibliographystyle{abbrv}
\bibliography{biblia}
\end{document}

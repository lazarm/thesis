\documentclass[a4paper,USenglish,numberwithinsect]{lipics}

\usepackage{graphicx}
\graphicspath{{figs/}}
\usepackage{latexsym}
\usepackage{url}
\usepackage{amssymb}
\usepackage{amsmath}
%\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{ifthen}
\usepackage{clrscode3e}
\usepackage{fancybox}
\usepackage{cite} % sort references within the same \cite command
\usepackage{enumerate} % fancy options for enumerate environment
\usepackage{microtype} % better line breaks and fewer overfull hboxes
\usepackage{varwidth}

\usepackage{todonotes}


%-- -- -- line numbers -- -- --
\usepackage[mathlines]{lineno}
\linenumbers
%-- -- -- line numbers -- -- --

%\usepackage{fullpage}

%\newtheorem{theorem}{Theorem}
%\newtheorem{corollary}[theorem]{Corollary}
%\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{problem}[theorem]{Problem}
%\newtheorem{proposition}[theorem]{Proposition}
%\newtheorem{conjecture}[theorem]{Conjecture}

\newcommand{\RR}{\ensuremath{\mathbb R}}  % real numbers
\newcommand{\ZZ}{\ensuremath{\mathbb Z}}  % integer numbers
\newcommand{\NN}{\ensuremath{\mathbb N}}  % natural numbers
\newcommand{\LL}{\ensuremath{\mathbb L}}  % 
\newcommand{\F}{\ensuremath{\mathcal{F}}}  
\newcommand{\D}{\ensuremath{\mathcal{D}}}  
\newcommand{\T}{\ensuremath{\mathcal{T}}}  
\newcommand{\GG}{\ensuremath{G_{\le 1}}}

\def\curve{\gamma}
\def\length{\mathit{len}}
\def\dist{\mathit{dist}}
\def\best{\mathit{best}}
\newcommand{\cycle}{\mathit{cycle}}
\newcommand{\walk}{\mathit{walk}}
\newcommand\CR{\mbox{\tt cr}_2}		  % crossing number

\def\DEF#1{\textbf{\emph{#1}}}
 
\let\leq\leqslant
\let\geq\geqslant
\let\le\leqslant
\let\ge\geqslant

\newcommand{\out}[1]{}

\def\myparagraph#1{\medskip\noindent\textbf{#1.}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Two Optimization Problems for Unit Disks}
\titlerunning{Two Optimization Problems for Unit Disks}


\author[1]{Sergio~Cabello\footnote{Supported by the Slovenian Research Agency, program P1-0297 and project L7-5459.}}
\author[2]{Lazar~Milinkovi\'c}
\authorrunning{Sergio Cabello and Lazar~Milinkovi\'c}

\affil[1]{FMF, University of Ljubljana, and 
	Institute of Mathematics, Physics and Mechanics, Slovenia}
\affil[2]{FMF and FRI, University of Ljubljana, Slovenia}

%------------------------------ Text -------------------------------------

\begin{document}
\maketitle

\begin{abstract}
	To be done
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

In this paper we consider two geometric optimization problems in the plane
where unit disks play a prominent role. For both problems 
we discuss efficient algorithms to solve them, provide an implementation
of these algorithms, and present experimental results on the implementation.

The first problem we consider is computing a \emph{shortest-path tree} 
in the (unweighted) intersection graph of unit disks. 
The input to the problem is a set $\D$ of $n$ disks of the same size, 
each disk represented by its center.
The corresponding unit disk (intersection) graph has a vertex for each disk,
and an edge connecting two disks $D$ and $D'$ of $\D$ whenever $D$ and $D'$ intersect.
An alternative, more convenient point of view, is to take as vertex set the set of
centers of the disks, denoted by $P$, and connecting two points $p$ and $q$ of $P$ 
whenever the Euclidean length $|pq|$ is at most the diameter of a disk. 
Given a root $r\in P$, the task is to compute a shortest-path tree from $r$ in this graph.

The second problem we consider is the \emph{minimum-separation problem}.
The input is a set $\D$ of $n$ unit disks in the plane and two points
$s$ and $t$ not covered by any disks of $\D$.
We say that $\D$ \emph{separates} $s$ and $t$ if each curve in the plane 
from $s$ to $t$ intersects some disk of $\D$.
The task is to find the minimum cardinality subset of $\D$
that separates $s$ and $t$. Formally, we want to solve
\begin{align*}
	\min ~~		& |\D'|\\
	 \mbox{s.t.}~~ & \D'\subset \D \text{ and $\D'$ separates $s$ and $t$}. 
\end{align*}

Unit disks are the most standard model used for wireless sensor networks; 
see for example~\cite{GG11,HS95,zg-wsn-04}. 
Often the model is referred as UDG.
This model provides an appropriate trade off between simplicity and accuracy. 
Other models are more accurate, as for example discussed in~\cite{KWZ03,LP10},
but obtaining efficient algorithm for them is much more difficult.

While unit disks give a simple model, exploiting the geometric features 
of the model is often challenging. 
Shortest paths in unit disk graphs are essential for routing and
are a basic subroutine for several other more complex tasks. 
A somehow unexpected application of shortest paths in unit-disk graphs
to boundary recognition is given in~\cite{WGM06}.
The minimum-separation problem and variants thereof have been considered 
in~\cite{CG16,gkv-ipud-11,pv-2013}. 
The problem is dual to the barrier-resilience problem considered in~\cite{BK09,KH07,KLA05,KLA07}.
It is not obvious that the minimum-separation problem can be solved optimally
in polynomial time, and the known algorithm for this uses as a subroutine 
shortest paths in unit disk graphs. 
Thus, both problems considered in this paper are related and it is worth to 
consider them together.


\myparagraph{Our contribution}
We are aware of two algorithms to compute shortest-path trees in unit disk graphs in
$O(n\log n)$ worst-case time: one by Cabello and Jej\v{c}i\v{c}~\cite{CJ15} and one Efrat, Itai and Katz~\cite{eik-01}. 
Here we report on an implementation of a modification of the algorithm in~\cite{CJ15},
and compare it against two obvious alternatives.
The only complex ingredient in the algorithm is computing the Delaunay triangulation,
but efficient libraries are available for this.
The algorithm of~\cite{eik-01} would be substantially harder to implement 
and it has worse constants hidden in the $O$-notation. 

As mentioned before, it is not obvious that the minimum-separation problem 
can be solved in polynomial time. 
A 2-approximation algorithm is given by Gibson, Kanade, and Varadarajan~\cite{gkv-ipud-11}. 
Cabello and Giannopoulos~\cite{CG16} provide an exact algorithm that takes $O(n^3)$ 
wosrt-case time and works for arbitrary shapes, not just disks. 
In this paper we improve this last algorithm to near-quadratic time for the 
special case of unit disks. 
The basic principle of the algorithm is the same, but several additional tools
from Computational Geometry have to be employed to reduce the worst-case running time. 
We implement a variant of the new, near-quadratic-time algorithm and report
on the experiments.


\myparagraph{Assumptions} 
We will assume that \emph{unit disk} means that it has radius $1/2$. 
Up to scaling the input data, this choice is irrelevant.
However, it is convenient for the exposition
because then the disks intersect whenever 
the distance between their centers is $1$. 
The implementation and the experiments also make this assumption.

Henceforth $P$ will be the set of centers of $\D$. 
All the computation will be concentrated on $P$. 
In particular, we assume that $P$ is known.
(For the shortest path problem, one could possibly consider weaker models based 
on adjacencies. )

We will work with the graph $\GG(P)$ with vertex set $P$ 
and an edge between two points $p,q\in P$ 
whenever their Euclidean distance $|pq|$ is at most $1$. 
In the notation we remove the dependency on $P$ and on the distance.
Thus we just use $G$ instead of $\GG(P)$.
For simplicity of the theoretical 
exposition we will sometimes assume that $G$ is connected.
It is trivial to adapt to the general case, for example
treating each connected component separately.
The implementation does not make this assumption.

In the minimum-separation problem we will use $s$ and $t$
for the points to separate. We will assume that $s$ is the origin and
$t$ is the point $(0,\tau)$, with $\tau\ge 0$. Thus, the segment $st$
is vertical and $t$ is above $s$. The implementation also makes
this assumption. A simple rigid transformation can be applied to
the input to get to this setting.

\myparagraph{Organization of the paper} 
In Section~\ref{sec:algorithms} we discuss the theoretical
algorithms for both problems and their guarantees.
In Section~\ref{sec:implementation} we discuss the implementations 
and in Section~\ref{sec:experiments} we present our experimental results.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Description of algorithms}
\label{sec:algorithms}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Shortest-path tree in unit-disk graphs}
\label{sec:algorithm-sptree}
We describe here the algorithm of Cabello and Jej\v{c}i\v{c}~\cite{CJ15} 
to compute a shortest path tree in $G$ from a given root point $r\in P$. 
As it is usually done for shortest path algorithms 
we use tables $\dist[\cdot]$ and $\pi[\cdot]$ indexed by the points of $P$ to record, 
for each point $p\in P$, the distance $d_{G}(s,p)$ and the ancestor of $p$ 
in a shortest $(s,p)$-path. 

The pseudocode of the algorithm, which we call \proc{UnweightedShortestPath},
 is in Figure~\ref{fig:BFS}. 
We explain the intuition, taken almost verbatim from~\cite{CJ15}.
We start by computing the Delaunay triangulation $DT(P)$ of $P$. 
We then proceed in rounds for increasing values of $i$, 
where at round $i$ we find the set $W_i$ of points at distance exactly $i$ in $G$ from the source $r$. We start with $W_0=\{ r\}$. 
At round $i$, we use $DT(P)$ to grow a neighbourhood around the points of $W_{i-1}$ 
that contains $W_{i}$. 
More precisely, we consider the points adjacent to $W_{i-1}$ in $DT(P)$ as candidate points for $W_{i}$. For each candidate point that is found to lie in $W_{i}$, we also take its adjacent vertices in $DT(P)$ as new candidates to be included in $W_{i}$. For checking whether a candidate point $p$ lies in $W_{i}$ we use a data structure to find a nearest neighbour of $p$ in $W_{i-1}$. If the distance from $p$ to its nearest neighbour $w$ in $W_{i-1}$ is
smaller than $1$, then the shortest path tree is extended by connecting $p$ to $w$.

\begin{figure}[htb]
\begin{center}
\ovalbox{~~~~
\begin{varwidth}{\linewidth}
\begin{codebox}
    \Procname{$\proc{UnweightedShortestPath}(P,r)$}
    \li build the Delaunay triangulation $DT(P)$
    \li \For$p\in P$ \Do
    	\li $\dist[p] \gets \infty$
    	\li $\pi[p] \gets \const{nil}$\End
    \li $\dist[r] \gets  0$
    \li $W_0 \gets \{ r\}$
    \li $i\gets1$
    \li \While $W_{i-1}\neq\emptyset$ \Do
    	\li build data structure for nearest neighbour queries in $W_{i-1}$
    	\li $Q \gets W_{i-1}$ \>\>\>\Comment candidate points
        \li $W_{i}\gets\emptyset$
    	\li \While $Q\neq\emptyset$\Do
    		\li $q$ an arbitrary point of $Q$
            \li remove $q$ from $Q$
            \li \For $qp$ edge in $DT(P)$ \Do
            	\li $w \gets$ nearest neighbour of $p$ in $W_{i-1}$
            	\li \If $\dist[p]=\infty$ and $|pw|\leq 1$ \Then
                	\li $\dist[p]\gets i$
                    \li $\pi[p]\gets w$
                    \li add $p$ to $Q$
                    \li add $p$ to $W_{i}$
                    \End
            	\End
            \End
        \li $i\gets i+1$
    \End
    \li \Return $\dist[\cdot]$ and $\pi[\cdot]$
    \\[-2mm]
\end{codebox}
\end{varwidth}
~~~~}\end{center}
\caption{Algorithm from~\cite{CJ15} to compute a shortest path tree in the unweighted case.}
\label{fig:BFS}
\end{figure}

Cabello and Jej\v{c}i\v{c}~\cite{CJ15} show that the algorithm correctly computes
the shortest-path tree from $r$. 
If for nearest neighbors we use a data structure that,
for $n$ points, has construction time $T_c(n)$ and query time $T_q(n)$, 
and the Delaunay triangulation is computed in $T_{DT}(n)$ time,
then the algorithm takes $O(T_{DT}(n)+ T_c(n)+ n T_q(n))$ time. 
Standards tools in Computational Geometry imply that 
$T_{DT}(n)=O(n\log n)$, $T_c(n)=O(nqlog n)$ and $T_q(n)=O(\log n)$.
This leads to the following.

\begin{theorem}[Cabello and Jej\v{c}i\v{c}~\cite{CJ15}]
  Let $P$ be a set of $n$ points in the plane and let $r$ be a point from $P$. 
  In time ${\mathcal O}(n \log n)$ we can compute a shortest path tree from $s$
  in the unweighted graph $\GG(P)$.
\end{theorem}

It is clear that, when computing the shortest path tree from several sources,
we only need to compute the Delaunay triangulation once.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Minimum separation with unit-disk}
\label{sec:algorithm-separation}

Cabello and Giannopouolos~\cite{CG16} present an algorithm
for the minimum separation problem that in the worst-case runs in cubic-time.
The algorithm has one feature that is both an advantage and a disadvantage: 
it works for any reasonable shapes, like segments or ellipses, and not just unit disks.
This means that it is very generic, which is good,
but it cannot exploit any properties of  unit disks.

In this section we are going to describe an algorithm to solve the minimum separation
problem \emph{for unit disks} in roughly quadratic time.
The improvement is based on 3 ingredients. 
The first ingredient is a reinterpretation of the algorithm of~\cite{CG16} 
for disks. In the original algorithm, we had to select a point inside each
shape. For disks there is a natural, obvious choice, the center of the disk.
This allows for a simpler description and interpretation of the algorithm.
We provide the description in Section~\ref{sec:generic}

The second ingredient is the efficient algorithm for shortest-path trees for the graph $G$.
The third ingredient is a compact treatment of the edges of $G$ using
a few tools from Computational Geometry, namely 
range trees, point-line duality, and nearest-neighbour searches.
This is explained in Section~\ref{sec:quadratic}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\subsubsection{Generic algorithm specialized for unit disks}
\label{sec:generic}
Let us first introduce some notation.
Each walk $W$ in the graph $G=\GG(P)$ defines a planar curve
in the obvious way: we connect the points of $P$ 
with segments in the order given by $W$. 
We will relax the notation slightly and denote also by $W$ the curve itself.
For any spanning tree $T$ of $G$ and any edge $e\in E(G)\setminus E(T)$, 
let $\cycle(T,e))$ be the unique cycle in $T+e$.
Finally, for any walk in $G(P)$, let $\CR (st,W)$ be the 
modulo $2$ value of the number of crossings between the segment $st$ 
and (the curve defined by) $W$.

The following property is implicit in~\cite{CG16} and explicit in~\cite{CK15}:
\begin{quote}
	Let $T$ be any spanning tree of $G$.
	The set of unit disks with centers in $P$ separate $s$ and $t$ if and only
	if there exists some edge $e\in E(G)\setminus E(T)$ 
	such that $\CR (st, \cycle(T,e))=1$.
\end{quote}

A consequence of this is that finding a minimum separation amounts 
to finding a shortest cycle $G$ that crosses the segment $st$ an odd number of times.
Moreover, one can show that we can restrict our search to 
a very concrete family cycles, as follows. 
For each root $r$ let us fix a shortest-path tree $T_r$ from $r$ in $G$.
When there are many, the choice of $T_r$ is irrelevant. 
Then, we can restrict our search to
\[
	\{ \cycle(T_r,e)\mid r\in P,~ e\in E(G)\setminus E(T_r)\}.
\]
This follows from the co-called 3-path condition; 
see~\cite{CG16} for the ideas, and \todo{APPENDIX} appendix~\ref{} 
for a self-contained proof.

The values $\CR (st, \cycle(T_r,e))$ can be computed in constant amortized time per edge
with some easy bookkeeping. Consider a fixed tree $T_r$.
For each point $p\in P$ we store $N[p]$ as the parity of the number of crossings
of the path in $T_r$ from $r$ to $p$. When $p$ is not the root,
the value $N[p]$ can be computed from the value of its parent $\pi[p]$ in $T_r$
using that $N[p]=N[\pi[p]]+\CR(st,p\pi[p])$.
In the algorithm we have written it this way (lines 4--6), but
one can of course compute the values at the time of computing the shortest path tree $T_r$.

We then have for each $T_r$
\begin{align*}
	\forall pq\in E(G)\setminus E(T_r):&~~~~
	\CR (st, \cycle(T_r,pq))= N[p]+N[q]+\CR(st,pq) \pmod 2\\
	\forall pq\in E(T_r):&~~~~
	0= N[p]+N[q]+\CR(st,pq) \pmod 2
\end{align*}
because crossings that are counted twice cancel out modulo $2$.
(In particular, the path in $T_r$ from $r$ to the lowest common ancestor of $p$ and $q$
is counted twice.)
This implies that we can just check for \emph{all} edges $pq$ of $G$ whether
the sum  $N[p]+N[q]+\CR(st,pq)$ is $0$ modulo $2$.
The final resulting algorithm, denoted as \proc{GenericMinimumSeparation},
is given in Figure~\ref{fig:generic}.

\begin{figure}[htb]
\begin{center}
\ovalbox{~~~~
\begin{varwidth}{\linewidth}
\begin{codebox}
    \Procname{$\proc{GenericMinimumSeparation}(P,s,t)$}
    \li $\best \gets \infty$ // length of the best separation so far
    \li \For $r\in P$ \Do
    	\li $(\dist[~],\pi[~])\gets$ shortest path tree from $r$ in $G(P)$
		\\ \> \Comment Compute $N[~]$
    	\li $N[r]=0$
    	\li \For $p\in P\setminus \{r\}$ in non-decreasing values of $\dist[p]$ \Do
			\li $N[p]= N[\pi[p]]+ \CR(st,p\pi[p]) \pmod 2$
			\End
    	\li \For $pq\in E(G(P))$\Do
			\li \If $N[p]+N[q]+ \CR(pq,st) \pmod 2 =1$ \Then
				\li $\best \gets \min \{ \best, \dist[p]+\dist[q]+1$ 
				\End
			\End
		\End
    \li \Return $\best$
    \\[-2mm]
\end{codebox}
\end{varwidth}
~~~~}\end{center}
\caption{Adaptation of the generic algorithm to compute the minimum separation for unit disks.}
\label{fig:generic}
\end{figure}


Let us look into the time complexity of the algorithm.
For each point $r\in P$ we have to compute a shortest-path tree in $G$.
This can be done in $O(n\log n)$ in our case, 
as discussed in Section~\ref{sec:algorithm-sptree}. 
Then, for each edge $pq$ of $G$ some constant amount of work is done.
Thus for each point $r$ we spend  
$O(n\log n+|E(G)|)$.
This is cubic in the worst-case.
We could get an improved running time if we can treat all the edges of $G$
compactly. This is what we explain next.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Compact treatment of edges}
\label{sec:quadratic}

We will use the following data structure.
The data structure is essentially a 2-dimensional range tree $T$ with
a data structure for nearest neighbour at each node of the secondary structure
of $T$.

\begin{lemma}
\label{lem:block}
	Let $B$ be a set of $n$ points with positive $x$-coordinates.
	We can preprocess $B$ in $O(n\log^3 n)$ time such that,
	for any query point $a$	with negative $x$-coordinate, 
	we can decide in $O(\log^3 n)$ time whether the set 
	$\{ b\in B \mid \text{$ab$ intersects $\sigma$ and $|ab|\le 1$}\}$
	is empty.
	A similar data structure with the same guarantees handles queries
	to know whether 
	$\{ b\in B \mid \text{$ab$ does not intersect $\sigma$ and $|ab|\le 1$}\}$
	is empty.
\end{lemma}
\begin{proof}
	We are going to use point-line duality and range trees.
	These are standard concepts in Computational Geometry.
	See for example~\cite[Chapters 5 and 8]{bkos-08}.
	
	We use the following precise point-line duality: 
	the non-vertical line $\ell \equiv y=mx+c$ 
	is mapped to the point $\ell^*=(m,-c)$ and
	vice-versa. 
	Let $\LL$ be the set of non-vertical lines.
	Let $\sigma$ be the line segment $st$.
	Let $\sigma^*$ be the set of points dual to non-vertical lines that intersect $\sigma$.
	Thus
	\[
		\sigma^* ~=~ \{ l^* \mid \ell\in \LL, \ell\cap \sigma\neq \emptyset\} 
	\]
	Since we assumed that $s=(0,0)$ and $t=(o,\tau)$, 
	in the dual space the set $\sigma^*$ is the horizontal slab 
	\[
		\sigma^* ~=~ \{ (m,-c)\in \RR^2\mid 0\le c\le \tau\}.
	\]
	
	For every point $p\in \RR^2$, outside the $y$-axis, 
	let $L^* _p$ be the set of points dual
	to the lines through $p$ that intersect $\sigma$:
	\[
		L^*_p=\{ \ell^* \mid \ell\in \LL, p \in \ell, \text{ and } \sigma\cap \ell\not= \emptyset\}.
	\]
	In the dual space, $L^*_p$ is a segment with endpoints 
	$(\varphi_1(p),0)$ and $(\varphi_2(p),\tau)$, 
	for some values $\varphi_1(p)$ and $\varphi_2(p)$
	that are easily computable.
	Namely, $\varphi_1(p)$ is the slope of the line through $p$
	and $(0,0)$ while $\varphi_2(p)$ is the slope of the line through $p$ and $(0,\tau)$.
	The segment $L^*_p$ is contained in the slab $\sigma^*$ and has the endpoints on
	different boundaries of $\sigma^*$.
	Finally, define the mapping $\varphi(p)=(\varphi_1(p),\varphi_2(p))$.
	Thus, $\varphi$ maps points in the plane with nonzero $x$-coordinate
	to points in the plane. 

	Let $a$ be any point to the left of the $y$-axis and 
	let $b$ be a point to the right of the $y$-axis.
	The segment $ab$ intersects $\sigma$ if and only if $L^*_a$ intersects $L^*_b$.
	Namely, an intersection of $L^*_a$ and $L^*_b$ is dual to the line
	through $a$ and $b$. The segments $L^*_a$ and $L^*_b$ intersect if
	and only if the order of their endpoints on boundaries of $\sigma^*$ are reversed.
	Moreover, since $a$ is to the left of the $y$-axis and $b$ is to the right
	of the $y$-axis, if the segment $ab$ intersects $\sigma$,
    then $\varphi_1(a)$, the slope of the line through $a$ and $(0,0)$,
    is smaller than $\varphi_1(b)$, the slope of the line through $b$ and $(0,0)$.
	Thus we have the following property:
	\[
		ab \cap \sigma \neq \emptyset ~\Longleftrightarrow ~ 
		\varphi_1(a)\le \varphi_1(b)) \text{ and } \varphi_2(a)\ge \varphi_2(b)).
	\]			
	Given a point $a$ to the left of the $y$ axis, 
	the set of points $b\in B$ with the property
	that $ab$ intersects $\sigma$ corresponds to the points $b$ with $\varphi(b)$
	in the bottom-right quadrant with apex $\varphi(a)$. 	
\todo{figure}

	We can use a $2$-dimensional range tree to store the point set $\varphi(B)$,
	where each point $b\in B$ is identified with its image $\varphi(b)$. 
	Moreover, for each node $v$ in the secondary level of the range tree, we 
	store a data structure for nearest neighbours for the canonical set $P(v)$ of points
	that are stored below $v$ in the secondary structure.
	
	For any query $a\in A$, the points $b\in B$ such that $ab$ intersects
	$\sigma$ are obtained by querying the 2-dimensional range tree for the points
	of $\varphi(B)$ contained in the quadrant 
	\[
		\{(x,y)\mid  \varphi_1(a) \le x \text{ and } \varphi_2(a) \ge y\}.
	\]
	This means that we get the set
	$\{ b\in B \mid \text{$ab$ intersects $\sigma$}\}$
	as the union of canonical subsets 
	$P(v_1),\dots,P(v_k)$ for $k=O(\log^2 n)$ nodes in the secondary structure
	of the 2-dimensional range tree.
	For each such canonical subset $P(v_i)$ we query for the nearest neighbour of $a$.
	If for some $v_i$ we get a nearest neighbour at distance at most $1$ from $a$,
	then we know that $\{ b\in B \mid \text{$ab$ intersects $\sigma$ and $|ab|\le 1$}\}$
	is non-empty. Otherwise the set is empty.

	The construction time of the 2-dimensional range tree is $O(n\log n)$.
	Each point appears in $O(\log^2 n)$ canonical subsets $P(v)$.
	This is, $\sum_v |P(v)| = O( n\log^2 n)$, where the sum iterates over
	all nodes $v$ in the secondary data structure.
	Since for each node $v$ in the secondary level we build a data structure for
	nearest neighbours, which takes $O(|P(v)| \log |P(v)|)$,
	the total construction time is $O( n\log^3 n)$.
	For the query time, the standard 2-dimensionsal range tree takes
	$O(\log^2 n)$ time to find the nodes $v_1,\dots, v_k$,
	and then we need additional $O(\log n)$ time per node.

	Answering the queries for 
	$\{ b\in B \mid \text{$ab$ does not intersect $\sigma$ and $|ab|\le 1$}\}$
	is done similarly (and the same data structure works), we just have
	to query for 2 of the other quadrants. (We do not need to query for the
	other 3 quadrants because one of them is always empty.)
\end{proof}

From the theoretical perspective is would be more efficient to compute the union
of the $|B|$ regions
\[
	\{ (x,y)\in \RR^2\mid x<0,~ |(x,y)b|\le 1,~ ((x,y) 
			\text{ intersects } \sigma \} ,~~ b\in B
\]
and make point location there. Since the regions cannot have many crossings,
good assymptotic bounds can be obtained. However, such approach seems to be 
only of theoretical interest and the improvement on the overall result
is rather marginal.

Consider now a fixed root $r$. Assume that we have computed 
the shortest path tree $T_r$ and the corresponding tables $\pi[~]$, $\dist[~]$ and $N[~]$,
as discussed in Section~\ref{sec:generic}.
We group the points by their distance from $r$:
\[
	W_i ~=~ \{ p\in P \mid \dist[p]=i \},~~~ i=0,1,\dots ,n
\]
A standard property of BFS trees, that also holds here,
is that all the distances from the root for any two adjacent vertices differ by at most $1$.
That is, the neighbours of a point $p\in P$ in $G$ are contained in
$W_{\dist[p]-1}\cup W_{\dist[p]} \cup W_{\dist[p]+1}$.

We make groups $L_i^j$ and $R_i^j$ (where $L$ stands for left and $R$ for right) 
defined by
\begin{align*}
	L_i^j ~&=~ \{ p\in P \mid \dist[p]=i,~ p.x<0,~ N[p]=j \} ,
	~~~\text{where $j=0,1$ and $i=0,1,\dots$}\\
	R_i^j ~&=~ \{ p\in P \mid \dist[p]=i,~ p.x>0,~ N[p]=j \} ,
	~~~\text{where $j=0,1$ and $i=0,1,\dots$}
\end{align*}
We are interested in edges $pq$ of $G$ such that $N[p]+N[q]+\CR(st,pq)=1 \pmod 2$. 
Up to symmetry (exchanging $p$ and $q$), this is equivalent to pairs of points
$(p,q)$ in one of the following two cases:
\begin{itemize}
	\item for some $i\in \NN$ we have, 
			$p\in L_i^j\cup R_i^j$, 
			$q\in L_i^{1-j}\cup R_i^{1-j}\cup L_{i-1}^{1-j}\cup R_{i-1}^{1-j}$, 
			$|pq|\le 1$, and $pq$ does not cross $st$;
	\item $p\in L_i^j\cup R_i^j$, 
			$q\in L_i^{j}\cup R_i^{j}\cup L_{i-1}^{j}\cup R_{i-1}^{j}$, 
			$|pq|\le 1$, and $pq$ crosses $st$.
\end{itemize}
Each one of these cases can be solved efficiently.
Up to symmetry and indices, we have the following cases:
\begin{itemize}
\item If we want to search the candidates $(p,q)\in L_i^j\times L_{i'}^{1-j}$
	that do not cross $st$,	we first preprocess $L_i^j$ for nearest neighbours.
	Then for each point $q$ in $L_{i'}^{1-j}$ we do the following:
	we query to get its nearest neighbour in $L_i^j$, and
	if their distance is at most $1$, then we have
	obtained a cycle of length (at most) $i+i'+1$ crossing $st$ an odd number of times.
	The overall running time, if $m=|L_i^j|+|L_{i'}^{1-j}|$, is
	$O(m\log m)$.
\item If we want to search the candidates $(p,q)\in L_i^j\times R_{i'}^{j}$
	such that $pq$ crosses $st$,
	we first preprocess $R_{i'}^{1-j}$ as discussed in Lemma~\ref{lem:block}
	into a data structure.
	Then, for each point $p\in L_i^j$ we query the data structure (for crossing $st$).
	If we get some nonempty set, then we got a cycle
	of length (at most) $i+i'+1$ that crosses $st$ an odd number of times.
	The overall running time, if $m=|L_i^j|+|R_{i'}^{j}|$, is
	$O(m\log^3 m)$.
\item If we want to search the candidates $(p,q)\in L_i^j\times R_{i'}^{1-j}$
	such that $pq$ does not cross $st$,
	we first preprocess $R_{i'}^{1-j}$ as in Lemma~\ref{lem:block}
	into a data structure.
	Then, for each point $p\in L_i^j$ we query the data structure (for not crossing $st$).
	If we get some nonempty set, then we got a cycle
	of length (at most) $i+i'+1$ that crosses $st$ an odd number of times.
	The overall running time, if $m=|L_i^j|+|R_{i'}^{1-j}|$, is
	$O(m\log^3 m)$.
\end{itemize}
We conclude that each of the cases can be done in $O(m\log^3 m)$ time, where
$m$ is the number of points involved in the case.
It is now easy to convert this into an algorithm that spends $O(n\log^3 n)$ time
per root $r$. The algorithm

\begin{figure}[htb]
\begin{center}
\ovalbox{~~~~
\begin{varwidth}{\linewidth}
\begin{codebox}
    \Procname{$\proc{GenericMinimumSeparation}(P,s,t)$}
    \li $\best \gets n+1$ // length of the best separation so far
    \li \For $r\in P$ \Do
    	\li $(\dist[~],\pi[~])\gets$ shortest path tree from $r$ in $G(P)$
		\\ \> \Comment Compute the levels $W_i$
    	\li \For $i=0\dots n$ \Do
			\li $W_i\gets$ new empty list
			\End
    	\li \For $p\in P$ \Do
			\li add $p$ to $W_{\dist[p]}$
			\End		
		\\ \> \Comment Compute $N[~]$ for the elements of $W_i$ and
		\\ \> \Comment and construct $L_i^0,L_i^1,R_i^0,R_i^1$
    	\li $N[r]=0$
		\li \For $i=1\dots n$ \Do
			\li \For $p\in W_i$ \Do
				\li $N[p]= N[\pi[p]]+ \CR(st,p\pi[p]) \pmod 2$
				\li \If $p$ to the left of the $y$-axis \Then
					\li add $p$ to $L^{N[p]}_i$
					\End
				\li \If $p$ to the right of the $y$-axis \Then
					\li add $p$ to $R^{N[p]}_i$
					\End
				\li Preprocess $R^0_i$ and $R^1_i$ as in Lemmas~\ref{adfafda}
				\li Preprocess $L^1_i$ and $R^1_i$ for nearest neighbours
				\End
			\End
    	\li $i=1$
    	\li \While $i\le \best/2$ \Do
			\\ \>\> \Comment cases within each side
			\li search candidates in $L^0_i\times L^1_{i-1}$
			\li search candidates in $L^0_i\times L^1_{i}$
			\li search candidates in $L^1_i\times L^0_{i-1}$
			\li search candidates in $R^0_i\times R^1_{i-1}$
			\li search candidates in $R^0_i\times R^1_{i}$
			\li search candidates in $R^1_i\times R^0_{i-1}$
			\\ \>\> \Comment cases across $y$-axis crosing $\sigma$
			\li search candidates in $L^0_i\times R^0_{i-1}$ crossing $\sigma$
			\li search candidates in $L^0_i\times R^0_{i}$ crossing $\sigma$
			\li search candidates in $L^1_i\times R^1_{i-1}$ crossing $\sigma$
			\li search candidates in $L^1_i\times R^1_{i}$ crossing $\sigma$
			\li search candidates in $L^0_{i-1}\times R^0_{i}$ crossing $\sigma$
			\li search candidates in $L^1_{i-1}\times R^1_{i}$ crossing $\sigma$
			\\ \>\> \Comment cases across $y$-axis not crosing $\sigma$			
			\li search candidates in $L^0_i\times R^1_{i-1}$ not crossing $\sigma$
			\li search candidates in $L^0_i\times R^1_{i}$ not crossing $\sigma$
			\li search candidates in $L^1_i\times R^0_{i-1}$ not crossing $\sigma$
			\li search candidates in $L^1_i\times R^0_{i}$ not crossing $\sigma$
			\li search candidates in $L^0_{i-1}\times R^0_{i}$ not crossing $\sigma$
			\li search candidates in $L^0_{i-1}\times R^1_{i}$ not crossing $\sigma$
			\li $i \gets i+1$
			\End
    \li \Return $\best$
    \\[-2mm]
\end{codebox}
\end{varwidth}
~~~~}\end{center}
\caption{New algorithm for minimum separation with unit disks.}
\label{fig:generic}
\end{figure}

Actually, we could compute the values $N[~]$ as they are needed.

We do not need to consider indices $i$ larger than $best$ 

\proc{FullAlgorithmSeparationUnitDisks} is given in Figure~\ref{fig:FULL}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
\label{sec:implementation}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Shortest-path tree in unit-disk graphs}
\label{sec:implementation-sptree}

\myparagraph{Alternative constructions} 
Let us mention two obvious alternatives that we use in our comparison.

The first alternative is to build the graph $G=\GG(P)$ explicitly. 
Thus, for each pair of points $p,q$ we check whether their distance is
at most once and add an edge to a graph data structure.
We can then use breadth-first-search (BFS) from the given root $r$.
The preprocessing is quadratic, and the time spent to compute
a shortest-path tree depends on the density of the graph $G$.

The second option we consider is to use a unit-length grid. 
Two points $(x,y)$ and $(x',y')$ are in the same grid cell
if and only if 
$(\lfloor x\rfloor ,\lfloor y\rfloor)=(\lfloor x'\rfloor ,\lfloor y'\rfloor)$.
We store all the points of a grid cell $c$ in a list $\ell(c)$.
The non-empty lists $\ell(c)$ are stored in a dictionary,
where the bottom-left corner of the cell is used as key.
We can then run some sort of BFS using this data. When processing
a point $p$ in a cell $c$, we have to treat all the points 
in $c$ and its adjacent cells as candidate points. 
The preprocessing is linear, and the time spent to compute
a shortest-path tree depends on the density of the graph $G$.
The number of candidates that are checked is proportional to the
number of edges of the graph.
\todo{Are perhaps points deleted from the list once they are assigned a level?}


%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Minimum separation with unit-disk}
\label{sec:implementation-separation}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Experimental results}
\label{sec:experiments}

Data was generated uniformly at random in polygons...


\begin{figure}
	\includegraphics[width=\textwidth,page=1]{data_generation}
	\caption{Data generation with a small hole (left) and a large hole (right).}
	\label{fig:data_generation}
\end{figure}

\begin{figure}
	\includegraphics[width=\textwidth,page=2]{data_generation}
	\caption{Data generation with four small holes (right) and four large holes (right).}
	\label{fig:data_generation}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Shortest-path tree in unit-disk graphs}
\label{sec:experiments-sptree}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Minimum separation with unit-disk}
\label{sec:experiments-separation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusions}
\label{sec:conclusions}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{abbrv}
\bibliography{biblio}



\newpage
\begin{appendix}

\section{Missing proofs}

3-path condition



\section{Full new algorithm for separation with unit disks}

\begin{figure}[htb]
\begin{center}
\ovalbox{~~~~
\begin{varwidth}{\linewidth}
\begin{codebox}
    \Procname{$\proc{FullAlgorithmSeparationUnitDisks}(P,s,t)$}
    \li $\best \gets n+1$ // length of the best separation so far
    \li \For $r\in P$ \Do
    	\li $(\dist[~],\pi[~])\gets$ shortest path tree from $r$ in $G(P)$
		\\ \> \Comment Compute the levels $W_i$
    	\li \For $i=0\dots n$ \Do
			\li $W_i\gets$ new empty list
			\End
    	\li \For $p\in P$ \Do
			\li add $p$ to $W_{\dist[p]}$
			\End		
		\\ \> \Comment Compute $N[~]$ for the elements of $W_i$ and
		\\ \> \Comment and construct $L_i^0,L_i^1,R_i^0,R_i^1$
    	\li $N[r]=0$
		\li \For $i=1\dots n$ \Do
			\li \For $p\in W_i$ \Do
				\li $N[p]= N[\pi[p]]+ \CR(st,p\pi[p]) \pmod 2$
				\li \If $p$ to the left of the $y$-axis \Then
					\li add $p$ to $L^{N[p]}_i$
					\End
				\li \If $p$ to the right of the $y$-axis \Then
					\li add $p$ to $R^{N[p]}_i$
					\End
				\li Preprocess $R^0_i$ and $R^1_i$ as in Lemmas~\ref{adfafda}
				\li Preprocess $L^1_i$ and $R^1_i$ for nearest neighbours
				\End
			\End
    	\li $i=1$
    	\li \While $i\le \best/2$ \Do
			\\ \>\> \Comment cases within each side
			\li search candidates in $L^0_i\times L^1_{i-1}$
			\li search candidates in $L^0_i\times L^1_{i}$
			\li search candidates in $L^1_i\times L^0_{i-1}$
			\li search candidates in $R^0_i\times R^1_{i-1}$
			\li search candidates in $R^0_i\times R^1_{i}$
			\li search candidates in $R^1_i\times R^0_{i-1}$
			\\ \>\> \Comment cases across $y$-axis crosing $\sigma$
			\li search candidates in $L^0_i\times R^0_{i-1}$ crossing $\sigma$
			\li search candidates in $L^0_i\times R^0_{i}$ crossing $\sigma$
			\li search candidates in $L^1_i\times R^1_{i-1}$ crossing $\sigma$
			\li search candidates in $L^1_i\times R^1_{i}$ crossing $\sigma$
			\li search candidates in $L^0_{i-1}\times R^0_{i}$ crossing $\sigma$
			\li search candidates in $L^1_{i-1}\times R^1_{i}$ crossing $\sigma$
			\\ \>\> \Comment cases across $y$-axis not crosing $\sigma$			
			\li search candidates in $L^0_i\times R^1_{i-1}$ not crossing $\sigma$
			\li search candidates in $L^0_i\times R^1_{i}$ not crossing $\sigma$
			\li search candidates in $L^1_i\times R^0_{i-1}$ not crossing $\sigma$
			\li search candidates in $L^1_i\times R^0_{i}$ not crossing $\sigma$
			\li search candidates in $L^0_{i-1}\times R^0_{i}$ not crossing $\sigma$
			\li search candidates in $L^0_{i-1}\times R^1_{i}$ not crossing $\sigma$
			\li $i \gets i+1$
			\End
    \li \Return $\best$
    \\[-2mm]
\end{codebox}
\end{varwidth}
~~~~}\end{center}
\caption{New algorithm for minimum separation with unit disks.}
\label{fig:FULL}
\end{figure}


\end{appendix}
\end{document}